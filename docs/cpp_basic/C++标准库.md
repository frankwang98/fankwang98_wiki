### ğŸ˜1. æ ‡å‡†åº“ä»‹ç»

C++ æ ‡å‡†åº“æ˜¯ C++ è¯­è¨€æä¾›çš„æ ‡å‡†åº“ï¼Œå®ƒåŒ…å«äº†å¤šä¸ªæ¨¡å—ï¼ˆå¤´æ–‡ä»¶ï¼‰ï¼Œæ¯ä¸ªæ¨¡å—æä¾›äº†ä¸åŒçš„åŠŸèƒ½ã€‚

C++ æ ‡å‡†æ¨¡æ¿åº“ï¼ˆSTLï¼ŒStandard Template Libraryï¼‰æ˜¯ C++ çš„ä¸€éƒ¨åˆ†ï¼Œæä¾›äº†ä¸€ç»„é€šç”¨çš„æ¨¡æ¿ç±»å’Œå‡½æ•°ï¼Œç”¨äºå®ç°å¸¸è§çš„æ•°æ®ç»“æ„å’Œç®—æ³•ã€‚

STLä¸»è¦åŒ…å«ä»¥ä¸‹ä¸‰ä¸ªç»„ä»¶ï¼š

- **å®¹å™¨ï¼ˆContainersï¼‰**ï¼š  
å®¹å™¨æ˜¯STLä¸­ç”¨äºå­˜å‚¨å’Œç®¡ç†æ•°æ®çš„ç±»æ¨¡æ¿ã€‚STLæä¾›äº†å„ç§ä¸åŒç±»å‹çš„å®¹å™¨ï¼ŒåŒ…æ‹¬åŠ¨æ€æ•°ç»„ï¼ˆvectorï¼‰ã€åŒå‘é“¾è¡¨ï¼ˆlistï¼‰ã€é˜Ÿåˆ—ï¼ˆqueueï¼‰ã€æ ˆï¼ˆstackï¼‰ã€é›†åˆï¼ˆsetï¼‰ã€æ˜ å°„ï¼ˆmapï¼‰ç­‰ã€‚æ¯ç§å®¹å™¨éƒ½å…·æœ‰ä¸åŒçš„ç‰¹ç‚¹å’Œé€‚ç”¨åœºæ™¯ï¼Œå¼€å‘äººå‘˜å¯ä»¥æ ¹æ®éœ€è¦é€‰æ‹©åˆé€‚çš„å®¹å™¨æ¥å­˜å‚¨å’Œæ“ä½œæ•°æ®ã€‚

- **ç®—æ³•ï¼ˆAlgorithmsï¼‰**ï¼š  
ç®—æ³•æ˜¯STLä¸­ç”¨äºå¤„ç†å®¹å™¨ä¸­æ•°æ®çš„å‡½æ•°æ¨¡æ¿ã€‚STLæä¾›äº†å¤§é‡çš„ç®—æ³•ï¼ŒåŒ…æ‹¬æŸ¥æ‰¾ã€æ’åºã€åˆå¹¶ã€æ›¿æ¢ã€è®¡æ•°ç­‰ã€‚è¿™äº›ç®—æ³•å®ç°äº†å¸¸è§çš„æ•°æ®å¤„ç†æ“ä½œï¼Œå¹¶ä¸”å¯¹äºå¤šæ•°æƒ…å†µä¸‹éƒ½æœ‰é«˜æ•ˆçš„å®ç°ã€‚å¼€å‘äººå‘˜å¯ä»¥é€šè¿‡ç®€å•åœ°è°ƒç”¨è¿™äº›ç®—æ³•ï¼Œè€Œæ— éœ€è‡ªå·±å®ç°å¤æ‚çš„æ•°æ®å¤„ç†é€»è¾‘ã€‚

- **è¿­ä»£å™¨ï¼ˆIteratorsï¼‰**ï¼š  
è¿­ä»£å™¨æ˜¯STLä¸­ç”¨äºéå†å®¹å™¨ä¸­å…ƒç´ çš„æŠ½è±¡æ¦‚å¿µã€‚é€šè¿‡ä½¿ç”¨è¿­ä»£å™¨ï¼Œå¼€å‘äººå‘˜å¯ä»¥åœ¨ä¸å…³å¿ƒå…·ä½“å®¹å™¨å®ç°çš„æƒ…å†µä¸‹ï¼Œå¯¹å®¹å™¨ä¸­çš„å…ƒç´ è¿›è¡Œè¿­ä»£å’Œè®¿é—®ã€‚STLæä¾›äº†å¤šç§ç±»å‹çš„è¿­ä»£å™¨ï¼ŒåŒ…æ‹¬è¾“å…¥è¿­ä»£å™¨ã€è¾“å‡ºè¿­ä»£å™¨ã€æ­£å‘è¿­ä»£å™¨ã€åŒå‘è¿­ä»£å™¨å’Œéšæœºè®¿é—®è¿­ä»£å™¨ã€‚ä¸åŒç±»å‹çš„è¿­ä»£å™¨æ”¯æŒä¸åŒçš„æ“ä½œå’ŒåŠŸèƒ½ï¼Œå¼€å‘äººå‘˜å¯ä»¥æ ¹æ®éœ€è¦é€‰æ‹©é€‚åˆçš„è¿­ä»£å™¨ã€‚

STLçš„ä¼˜ç‚¹æœ‰ï¼š

1. å¯é‡ç”¨æ€§ï¼šSTLæä¾›äº†é€šç”¨çš„æ•°æ®ç»“æ„å’Œç®—æ³•ï¼Œå¯ä»¥åœ¨ä¸åŒçš„é¡¹ç›®å’Œåœºæ™¯ä¸­é‡å¤ä½¿ç”¨ï¼Œé¿å…äº†é‡å¤ç¼–å†™ç›¸ä¼¼çš„ä»£ç ã€‚  
2. é«˜æ•ˆæ€§ï¼šSTLä¸­çš„å®¹å™¨å’Œç®—æ³•éƒ½ç»è¿‡äº†ä¼˜åŒ–ï¼Œå…·æœ‰é«˜æ•ˆçš„å®ç°ã€‚STLä½¿ç”¨äº†æ¨¡æ¿å’Œå†…è”å‡½æ•°ç­‰æŠ€æœ¯ï¼Œåœ¨ç¼–è¯‘æ—¶ç”Ÿæˆé«˜æ•ˆçš„ä»£ç ã€‚  
3. å¯æ‰©å±•æ€§ï¼šSTLæ”¯æŒç”¨æˆ·è‡ªå®šä¹‰ç±»å‹çš„å®¹å™¨å’Œç®—æ³•ï¼Œå¯ä»¥æ ¹æ®å®é™…éœ€æ±‚è¿›è¡Œæ‰©å±•å’Œå®šåˆ¶ã€‚  
4. ä»£ç å¯è¯»æ€§å’Œå¯ç»´æŠ¤æ€§ï¼šSTLæä¾›äº†ä¸€è‡´çš„æ¥å£å’Œå‘½åè§„èŒƒï¼Œä½¿å¾—ä»£ç æ›´æ˜“äºç†è§£å’Œç»´æŠ¤ã€‚åŒæ—¶ï¼ŒSTLä¸­çš„å®¹å™¨å’Œç®—æ³•éƒ½ç»è¿‡äº†å¹¿æ³›æµ‹è¯•å’ŒéªŒè¯ï¼Œå…·æœ‰è¾ƒé«˜çš„å¯é æ€§ã€‚

ä¸¤ä¸ªåœ¨çº¿å­¦ä¹ åœ°å€ï¼š

```bash
https://cui-jiacai.gitbook.io/c++-stl-tutorial/
https://zoupers.gitbook.io/cpp-17-stl-cookbook/

```

### ğŸ˜Š2. å¸¸ç”¨å®¹å™¨æ¨¡å—

å®¹å™¨ä¸»è¦æœ‰åºåˆ—å®¹å™¨ï¼ˆarrayã€vectorã€dequeueã€forward_listã€listï¼‰å’Œå…³è”å®¹å™¨ï¼ˆmapã€setã€multimapã€multisetï¼‰ï¼Œåˆ†åˆ«ç”¨äºä¸åŒçš„æ•°æ®å­˜å‚¨å’Œè®¿é—®æ–¹å¼ã€‚

[stl-å®¹å™¨](./ã€C++ã€‘åŸºç¡€ï¼šSTLå®¹å™¨åº“.md)

#### stringï¼šå­—ç¬¦ä¸²ï¼ŒæŠ½è±¡char*

```cpp
std::string str("hello");
// åé¢è¿½åŠ 
str.append(" world");
// å‰é¢æ’å…¥
str.insert(0, "ok,");
// æˆªå–å­å­—ç¬¦ä¸²
str = str.substr(3);
printf("sub str=%s\n", str.c_str());
// ç©ºæ ¼æ›¿æ¢ä¸ºé€—å·
for (int i = 0; i < str.size(); ++i) {
    char ch = str.at(i);
    if (ch == ' ') {
        str.replace(i, 1, 1, ',');
    }
}
// åé¢æ·»åŠ å­—ç¬¦
str.push_back('!');
// åˆ é™¤æŒ‡å®šä½ç½®çš„å­—ç¬¦
str.erase(str.size() - 1);
size_t pos = str.find("world");
printf("find pos=%ld\n", pos);
// åˆ¤æ–­å­—ç¬¦ä¸²æ˜¯å¦ç›¸ç­‰ï¼Œ== å±äºæ“ä½œç¬¦é‡è½½
if (str == "hello,world") {
    // ...
}

```

#### vectorï¼šåŠ¨æ€æ•°ç»„ï¼Œæ”¯æŒå¿«é€Ÿéšæœºè®¿é—®ã€‚

```cpp
#include <iostream>
#include <vector>
#include <array>
using namespace std;
int main()
{
    std::vector<int> demo{ 1,2 };

    demo.push_back(1); //push_backæ“ä½œ

    std::vector<int> test{ 3,4,5 };
    demo.insert(demo.end(), test.begin(), test.end()); //insetæ“ä½œ

    // å¾ªç¯æ‰“å°å€¼
    for (int i = 0; i < demo.size(); i++) {
        cout << demo[i] << " ";
    }

    // ä½¿ç”¨è¿­ä»£å™¨ iterator è®¿é—®å€¼
    vector<int>::iterator v = demo.begin();
    while (v != demo.end()) {
        cout << "value of v = " << *v << endl;
        v++;
    }
    return 0;
}

```

#### listï¼šåŒå‘é“¾è¡¨ï¼Œæ”¯æŒé«˜æ•ˆçš„æ’å…¥å’Œåˆ é™¤æ“ä½œã€‚

```cpp
#include <iostream>
#include <list>

int main() {
    // åˆ›å»ºä¸€ä¸ªç©ºçš„listå®¹å™¨
    std::list<int> myList;

    // åœ¨å®¹å™¨å°¾éƒ¨æ’å…¥å…ƒç´ 
    myList.push_back(10);
    myList.push_back(20);
    myList.push_back(30);

    // åœ¨å®¹å™¨å¤´éƒ¨æ’å…¥å…ƒç´ 
    myList.push_front(5);

    // ä½¿ç”¨è¿­ä»£å™¨éå†è¾“å‡ºå®¹å™¨ä¸­çš„å…ƒç´ 
    std::cout << "List elements: ";
    for (auto it = myList.begin(); it != myList.end(); ++it) {
        std::cout << *it << " ";
    }
    std::cout << std::endl;

    // åœ¨æŒ‡å®šä½ç½®æ’å…¥å…ƒç´ 
    auto insertPos = std::find(myList.begin(), myList.end(), 20);
    if (insertPos != myList.end()) {
        myList.insert(insertPos, 15);
    }

    // ä½¿ç”¨è¿­ä»£å™¨åå‘éå†è¾“å‡ºå®¹å™¨ä¸­çš„å…ƒç´ 
    std::cout << "Reversed List elements: ";
    for (auto rit = myList.rbegin(); rit != myList.rend(); ++rit) {
        std::cout << *rit << " ";
    }
    std::cout << std::endl;

    // ç§»é™¤æŒ‡å®šå€¼çš„å…ƒç´ 
    myList.remove(10);

    // æ¸…ç©ºå®¹å™¨
    myList.clear();

    return 0;
}

```

#### queueï¼šé˜Ÿåˆ—

```cpp
std::queue<int> queue;
// å…¥é˜Ÿ
queue.push(111);
queue.push(222);
queue.push(333);
printf("queue front=%d, back=%d", queue.front(), queue.back());
// å‡ºé˜Ÿ
while (!queue.empty()) {
    int front = queue.front();
    queue.pop();
}

```

#### dequeï¼šåŒç«¯é˜Ÿåˆ—ï¼Œæ”¯æŒé¦–å°¾æ’å…¥å’Œåˆ é™¤æ“ä½œã€‚

```cpp
#include <iostream>
#include <deque>

int main() {
    // åˆ›å»ºä¸€ä¸ªç©ºçš„dequeå®¹å™¨
    std::deque<int> myDeque;

    // åœ¨å®¹å™¨å°¾éƒ¨æ’å…¥å…ƒç´ 
    myDeque.push_back(10);
    myDeque.push_back(20);
    myDeque.push_back(30);

    // åœ¨å®¹å™¨å¤´éƒ¨æ’å…¥å…ƒç´ 
    myDeque.push_front(5);

    // ä½¿ç”¨ç´¢å¼•è®¿é—®å’Œè¾“å‡ºå®¹å™¨ä¸­çš„å…ƒç´ 
    std::cout << "Deque elements: ";
    for (size_t i = 0; i < myDeque.size(); ++i) {
        std::cout << myDeque[i] << " ";
    }
    std::cout << std::endl;

    // åœ¨æŒ‡å®šä½ç½®æ’å…¥å…ƒç´ 
    auto insertPos = myDeque.begin() + 2;
    myDeque.insert(insertPos, 15);

    // ä½¿ç”¨è¿­ä»£å™¨éå†è¾“å‡ºå®¹å™¨ä¸­çš„å…ƒç´ 
    std::cout << "Deque elements after insertion: ";
    for (auto it = myDeque.begin(); it != myDeque.end(); ++it) {
        std::cout << *it << " ";
    }
    std::cout << std::endl;

    // ç§»é™¤æŒ‡å®šä½ç½®çš„å…ƒç´ 
    auto erasePos = myDeque.begin() + 1;
    myDeque.erase(erasePos);

    // ä½¿ç”¨è¿­ä»£å™¨åå‘éå†è¾“å‡ºå®¹å™¨ä¸­çš„å…ƒç´ 
    std::cout << "Reversed Deque elements: ";
    for (auto rit = myDeque.rbegin(); rit != myDeque.rend(); ++rit) {
        std::cout << *rit << " ";
    }
    std::cout << std::endl;

    // æ¸…ç©ºå®¹å™¨
    myDeque.clear();

    return 0;
}

```

#### setï¼šé›†åˆï¼Œå­˜å‚¨å”¯ä¸€å€¼ï¼Œå¹¶æŒ‰ç…§ä¸€å®šçš„æ’åºè§„åˆ™è¿›è¡Œè‡ªåŠ¨æ’åºã€‚

```cpp
#include <iostream>
#include <set>

int main() {
    // åˆ›å»ºä¸€ä¸ªç©ºçš„setå®¹å™¨
    std::set<int> mySet;

    // å‘å®¹å™¨ä¸­æ’å…¥å…ƒç´ 
    mySet.insert(10);
    mySet.insert(20);
    mySet.insert(20);  // é‡å¤çš„å…ƒç´ å°†è¢«å¿½ç•¥
    mySet.insert(30);

    // åˆ¤æ–­å…ƒç´ æ˜¯å¦å­˜åœ¨
    if (mySet.find(20) != mySet.end()) {
        std::cout << "Element 20 is found in the set." << std::endl;
    } else {
        std::cout << "Element 20 is not found in the set." << std::endl;
    }

    // è¾“å‡ºå®¹å™¨ä¸­çš„å…ƒç´ ä¸ªæ•°
    std::cout << "Size of set: " << mySet.size() << std::endl;

    // ä½¿ç”¨èŒƒå›´å¾ªç¯éå†è¾“å‡ºå®¹å™¨ä¸­çš„å…ƒç´ 
    std::cout << "Set elements: ";
    for (const auto& element : mySet) {
        std::cout << element << " ";
    }
    std::cout << std::endl;

    // ç§»é™¤å…ƒç´ 
    int key = 10;
    mySet.erase(key);

    // æ£€æŸ¥å®¹å™¨æ˜¯å¦ä¸ºç©º
    if (mySet.empty()) {
        std::cout << "Set is empty." << std::endl;
    } else {
        std::cout << "Set is not empty." << std::endl;
    }

    return 0;
}

```

#### mapï¼šæ˜ å°„ï¼Œå­˜å‚¨é”®å€¼å¯¹ï¼ŒæŒ‰ç…§é”®çš„å¤§å°è¿›è¡Œè‡ªåŠ¨æ’åºã€‚

```cpp
#include <iostream>
#include <map>
#include <string>
using namespace std;
int main()
{
    map<string,int> phone_book; // åˆ›å»ºä¸€ä¸ªmapç±»å®¹å™¨ï¼Œç”¨äºå­˜å‚¨ç”µè¯å·ç ç°¿

    // åˆ›å»ºç”µè¯ç°¿
    phone_book["zhangsan"] = 12345678; // é€šè¿‡[]æ“ä½œå’Œå…³é”®å­—å¾€å®¹å™¨ä¸­åŠ å…¥å…ƒç´ 
    phone_book["lisi"] = 87654321;
    phone_book["wanger"] = 56781234;
    phone_book.insert(std::pair<string, int("zhangtian", 65458997));
    // ......
    // è¾“å‡ºç”µè¯å·ç ç°¿
    cout << "ç”µè¯å·ç ç°¿çš„ä¿¡æ¯å¦‚ä¸‹ï¼š\n";
    for (pair<string, int item: phone_book) {
        // for (auto it = phone_book,begin(); it != phone_book.end(); it++)
        // C++11ä¸­å¼•å…¥çš„enhanced-for loop
        cout << item.first << ": " << item.second << endl; 
        // è¾“å‡ºå…ƒç´ çš„å§“åå’Œç”µè¯å·ç 
    }

    // æŸ¥æ‰¾æŸä¸ªäººçš„ç”µè¯å·ç 
    string name;
    cout << "è¯·è¾“å…¥è¦æŸ¥è¯¢å·ç çš„å§“åï¼š";
    cin >> name;
    map<string,int::const_iterator it; // åˆ›å»ºä¸€ä¸ªä¸èƒ½ä¿®æ”¹æ‰€æŒ‡å‘çš„å…ƒç´ çš„è¿­ä»£å™¨
    it = phone_book.find(name); // æŸ¥æ‰¾å…³é”®å­—ä¸ºnameçš„å®¹å™¨å…ƒç´ 
    if (it == phone_book.end()) // åˆ¤æ–­æ˜¯å¦æ‰¾åˆ°
        cout << name << ": not found\n"; // æœªæ‰¾åˆ°
    else
        cout << it-first << ": " << it-second << endl; // æ‰¾åˆ°
    return 0;
}

```

#### unordered_setï¼šæ— åºä¸é‡å¤å…ƒç´ é›†åˆï¼Œå­˜å‚¨å”¯ä¸€å€¼ï¼Œå¹¶æä¾›å¸¸æ•°æ—¶é—´çš„æŸ¥æ‰¾æ“ä½œã€‚

```cpp
#include <iostream>
#include <unordered_set>

int main() {
    // åˆ›å»ºä¸€ä¸ª unordered_set
    std::unordered_set<int> mySet;

    // æ’å…¥å…ƒç´ 
    mySet.insert(10);
    mySet.insert(20);
    mySet.insert(30);

    // æŸ¥æ‰¾å…ƒç´ 
    if (mySet.find(20) != mySet.end()) {
        std::cout << "Element 20 found in set" << std::endl;
    } else {
        std::cout << "Element 20 not found in set" << std::endl;
    }

    // åˆ é™¤å…ƒç´ 
    mySet.erase(10);

    // éå†é›†åˆ
    for (const auto& elem : mySet) {
        std::cout << elem << " ";
    }
    std::cout << std::endl;

    return 0;
}
```


#### unordered_mapï¼šæ— åºæ˜ å°„ï¼Œå­˜å‚¨é”®å€¼å¯¹ï¼Œå¹¶æä¾›å¸¸æ•°æ—¶é—´çš„æŸ¥æ‰¾æ“ä½œã€‚

```cpp
#include <iostream>
#include <unordered_map>

int main() {
    // åˆ›å»ºä¸€ä¸ª unordered_mapï¼Œå°†å­—ç¬¦ä¸²æ˜ å°„åˆ°æ•´æ•°
    std::unordered_map<std::string, int> myMap;

    // æ’å…¥é”®å€¼å¯¹
    myMap["apple"] = 5;
    myMap["banana"] = 10;
    myMap["orange"] = 7;

    // æŸ¥æ‰¾å…ƒç´ 
    if (myMap.find("banana") != myMap.end()) {
        std::cout << "Price of banana: " << myMap["banana"] << std::endl;
    } else {
        std::cout << "Banana not found in map" << std::endl;
    }

    // ä¿®æ”¹å…ƒç´ 
    myMap["orange"] = 8;

    // éå† map
    for (const auto& pair : myMap) {
        std::cout << pair.first << ": " << pair.second << std::endl;
    }

    return 0;
}
```


### ğŸ˜†3. å¸¸ç”¨ç®—æ³•æ¨¡å—

#### sortï¼šå¯¹å®¹å™¨è¿›è¡Œæ’åºã€‚

```cpp
std::vector<int array{3, 6, 1, 5, 9, 2, 8};
std::sort(array.begin(), array.end());
for (int it: array) {
    printf("%d ", it);
}

```

#### findï¼šåœ¨å®¹å™¨ä¸­æŸ¥æ‰¾æŒ‡å®šå…ƒç´ ã€‚

```cpp
#include <vector>
#include <algorithm>
#include <iostream>
using namespace std;
int main() 
{
    int a[10] = { 10,20,30,40 };
    vector<int> v;
    v.push_back(1);    v.push_back(2);
    v.push_back(3);    v.push_back(4); //æ­¤åvé‡Œæ”¾ç€4ä¸ªå…ƒç´ ï¼š1,2,3,4

    // å®šä¹‰è¿­ä»£å™¨ï¼Œç”¨findæŸ¥æ‰¾
    vector<int>::iterator p;
    p = find(v.begin(), v.end(), 3); //åœ¨vä¸­æŸ¥æ‰¾3
    if (p != v.end()) //è‹¥æ‰¾ä¸åˆ°,findè¿”å› v.end()
        cout << "1. " << *p << endl; //æ‰¾åˆ°äº†
    
    p = find(v.begin(), v.end(), 9);
    if (p == v.end())
        cout << "not found " << endl; //æ²¡æ‰¾åˆ°

    p = find(v.begin() + 1, v.end() - 1, 4); //åœ¨,3 è¿™ä¸¤ä¸ªå…ƒç´ ä¸­æŸ¥æ‰¾4
    cout << "2. " << *p << endl;

    int * pp = find(a, a + 4, 20);
    if (pp == a + 4)
        cout << "not found" << endl;
    else
        cout << "3. " << *pp << endl;

    return 0;
}

```

#### binary_searchï¼šäºŒåˆ†æŸ¥æ‰¾

```cpp
bool result = std::binary_search(array.begin(), array.end(), 8);

```

#### removeï¼šä»å®¹å™¨ä¸­ç§»é™¤æŒ‡å®šå€¼ã€‚


#### transformï¼šå¯¹å®¹å™¨ä¸­çš„å…ƒç´ åº”ç”¨æŸä¸ªæ“ä½œå¹¶å­˜å‚¨ç»“æœã€‚


#### accumulateï¼šè®¡ç®—å®¹å™¨ä¸­å…ƒç´ çš„ç´¯åŠ å€¼ã€‚


#### countï¼šè®¡ç®—å®¹å™¨ä¸­æ»¡è¶³æ¡ä»¶çš„å…ƒç´ ä¸ªæ•°ã€‚


#### reverseï¼šåè½¬å®¹å™¨ä¸­çš„å…ƒç´ é¡ºåºã€‚

```cpp
std::reverse(array.begin(), array.end());

```

#### replaceï¼šæ›¿æ¢

```cpp
std::replace(array.begin(), array.end(), 6, 666);

```

### ğŸ˜†4. å…¶ä»–æ¨¡å—

#### å‡½æ•°å¯¹è±¡ï¼ˆFunction Objectsï¼‰

STLæä¾›äº†å‡½æ•°å¯¹è±¡ç±»æ¨¡æ¿ï¼Œå…è®¸ç”¨æˆ·è‡ªå®šä¹‰å‡½æ•°å¯¹è±¡ï¼Œå³é‡è½½å‡½æ•°è‡ªå®šä¹‰è¿ç®—ç¬¦ operator() çš„å¯¹è±¡ï¼ˆä¹Ÿç§°ä¸º**ä»¿å‡½æ•°**ï¼‰ï¼Œä»¥ä¾¿åœ¨ç®—æ³•ä¸­ä½¿ç”¨ã€‚  
å‡½æ•°å¯¹è±¡æ˜¯ä¸€ä¸ªè¡Œä¸ºç±»ä¼¼äºå‡½æ•°çš„å¯¹è±¡ï¼Œå¯ä»¥é‡è½½å‡½æ•°è°ƒç”¨è¿ç®—ç¬¦ operator()()ã€‚  
ä½¿ç”¨å‡½æ•°å¯¹è±¡å¯ä»¥å®ç°æ›´åŠ çµæ´»çš„ç®—æ³•æ“ä½œï¼ŒåŒ…æ‹¬è‡ªå®šä¹‰çš„æ’åºè§„åˆ™ã€æ¡ä»¶åˆ¤æ–­ç­‰ã€‚

```cpp
#include <iostream>

// å®šä¹‰ä¸€ä¸ªå‡½æ•°å¯¹è±¡ç±»
class MyFunctor {
public:
    void operator()(int x) const {
        std::cout << "Square of " << x << " is: " << x * x << std::endl;
    }
};

int main() {
    // åˆ›å»ºå‡½æ•°å¯¹è±¡å®ä¾‹
    MyFunctor myFunctor;
    // ä½¿ç”¨å‡½æ•°å¯¹è±¡è°ƒç”¨å®ƒçš„ operator() æ–¹æ³•
    myFunctor(5); // è¾“å‡ºï¼šSquare of 5 is: 25

    // å¯ä»¥ç›´æ¥åˆ›å»ºä¸´æ—¶å‡½æ•°å¯¹è±¡å¹¶è°ƒç”¨
    MyFunctor()(8); // è¾“å‡ºï¼šSquare of 8 is: 64

    return 0;
}
```

#### é€‚é…å™¨ï¼ˆAdaptersï¼‰

STLæä¾›äº†é€‚é…å™¨ç±»æ¨¡æ¿ï¼Œç”¨äºå°†å®¹å™¨æˆ–è¿­ä»£å™¨çš„æ¥å£è¿›è¡Œé€‚é…æˆ–æ‰©å±•ï¼Œä»¥æ»¡è¶³ç‰¹å®šçš„éœ€æ±‚ã€‚ 
å¸¸è§çš„é€‚é…å™¨æœ‰ `stackã€queueã€priority_queue`ï¼Œå®ƒä»¬åœ¨åº•å±‚ä½¿ç”¨äº†ä¸åŒçš„å®¹å™¨å®ç°ï¼Œå¹¶ä¸”æä¾›äº†ç‰¹å®šçš„æ¥å£å’ŒåŠŸèƒ½ã€‚

```cpp
#include <iostream>
#include <stack>

int main() {
    std::stack<int> myStack;

    // å°†å…ƒç´ å‹å…¥æ ˆä¸­
    myStack.push(10);
    myStack.push(20);
    myStack.push(30);

    // è®¿é—®æ ˆé¡¶å…ƒç´ 
    std::cout << "Top element of stack: " << myStack.top() << std::endl;

    // å¼¹å‡ºæ ˆé¡¶å…ƒç´ 
    myStack.pop();

    // æ£€æŸ¥æ ˆæ˜¯å¦ä¸ºç©º
    if (myStack.empty()) {
        std::cout << "Stack is empty" << std::endl;
    } else {
        std::cout << "Stack is not empty" << std::endl;
    }

    return 0;
}
```

#### åˆ†é…å™¨ï¼ˆAllocatorsï¼‰

STLå…è®¸ç”¨æˆ·è‡ªå®šä¹‰å†…å­˜åˆ†é…å™¨ï¼Œç”¨äºæ§åˆ¶å®¹å™¨å†…éƒ¨çš„å†…å­˜ç®¡ç†å’Œåˆ†é…ç­–ç•¥ã€‚  
ç”¨æˆ·å¯ä»¥é€šè¿‡å®ç°è‡ªå·±çš„åˆ†é…å™¨ç±»æ¥æ»¡è¶³ç‰¹å®šçš„å†…å­˜ç®¡ç†éœ€æ±‚ï¼Œä¾‹å¦‚å†…å­˜æ± ã€å®šåˆ¶çš„å†…å­˜åˆ†é…ç­–ç•¥ç­‰ã€‚

```cpp
#include <iostream>
#include <vector>
#include <memory>

int main() {
    // åˆ›å»ºä½¿ç”¨ std::allocator çš„ vector
    std::vector<int, std::allocator<int>> myVector;

    // å‘ vector æ·»åŠ å…ƒç´ 
    for (int i = 1; i <= 5; i++) {
        myVector.push_back(i);
    }

    // éå†å¹¶æ‰“å° vector ä¸­çš„å…ƒç´ 
    for (const auto& element : myVector) {
        std::cout << element << " ";
    }
    std::cout << std::endl;

    return 0;
}
```

#### è¿­ä»£å™¨æ¨¡å—ï¼ˆIterator Tagsï¼‰

STLä¸­å¼•å…¥äº†è¿­ä»£å™¨æ ‡ç­¾çš„æ¦‚å¿µï¼Œç”¨äºè¡¨ç¤ºè¿­ä»£å™¨çš„ç±»å‹å’Œç‰¹æ€§ã€‚  
è¿­ä»£å™¨æ ‡ç­¾åŒ…æ‹¬è¾“å…¥è¿­ä»£å™¨ã€è¾“å‡ºè¿­ä»£å™¨ã€å‰å‘è¿­ä»£å™¨ã€åŒå‘è¿­ä»£å™¨å’Œéšæœºè®¿é—®è¿­ä»£å™¨ï¼Œç”¨äºæŒ‡å®šè¿­ä»£å™¨æ”¯æŒçš„æ“ä½œå’ŒåŠŸèƒ½ã€‚

- è¾“å…¥è¿­ä»£å™¨ï¼ˆInput Iteratorsï¼‰ï¼šåªè¯»è®¿é—®å®¹å™¨ä¸­çš„å…ƒç´ ã€‚

- è¾“å‡ºè¿­ä»£å™¨ï¼ˆOutput Iteratorsï¼‰ï¼šåªå†™è®¿é—®å®¹å™¨ä¸­çš„å…ƒç´ ã€‚

- æ­£å‘è¿­ä»£å™¨ï¼ˆForward Iteratorsï¼‰ï¼šæ”¯æŒè¯»å†™å®¹å™¨ä¸­çš„å…ƒç´ ï¼Œå¹¶èƒ½å¤Ÿå‘å‰éå†ã€‚

- åŒå‘è¿­ä»£å™¨ï¼ˆBidirectional Iteratorsï¼‰ï¼šæ”¯æŒæ­£å‘å’Œé€†å‘éå†ã€‚

- éšæœºè®¿é—®è¿­ä»£å™¨ï¼ˆRandom Access Iteratorsï¼‰ï¼šæ”¯æŒä»»æ„ä½ç½®çš„é«˜æ•ˆéšæœºè®¿é—®ã€‚

#### å…ƒç¼–ç¨‹æŠ€æœ¯ï¼ˆMetaprogramming Techniquesï¼‰

STLå¹¿æ³›ä½¿ç”¨å…ƒç¼–ç¨‹æŠ€æœ¯ï¼ŒåŒ…æ‹¬æ¨¡æ¿ç‰¹åŒ–ã€æ¨¡æ¿åç‰¹åŒ–ã€æ¨¡æ¿å…ƒç¼–ç¨‹ã€SFINAEï¼ˆSubstitution Failure Is Not An Errorï¼‰ç­‰ã€‚ 
å…ƒç¼–ç¨‹æŠ€æœ¯å¯ä»¥åœ¨ç¼–è¯‘æœŸé—´è¿›è¡Œè®¡ç®—å’Œä»£ç ç”Ÿæˆï¼Œä»¥æé«˜ä»£ç çš„æ•ˆç‡å’Œçµæ´»æ€§ã€‚

```cpp
#include <iostream>

template <int N>
struct Fibonacci {
    static const int value = Fibonacci<N - 1>::value + Fibonacci<N - 2>::value;
};

template <>
struct Fibonacci<0> {
    static const int value = 0;
};

template <>
struct Fibonacci<1> {
    static const int value = 1;
};

int main() {
    const int result = Fibonacci<10>::value;
    std::cout << "Fibonacci number at position 10 is: " << result << std::endl;

    return 0;
}
```

#### å¼‚æ­¥æ“ä½œ

`å¼‚æ­¥æ“ä½œ`æ˜¯ä¸€ç§ç¼–ç¨‹æ¨¡å‹ï¼Œç”¨äºå¤„ç†ä»»åŠ¡çš„éé˜»å¡æ‰§è¡Œå’Œäº‹ä»¶é©±åŠ¨ã€‚åœ¨ä¼ ç»Ÿçš„åŒæ­¥æ“ä½œä¸­ï¼Œç¨‹åºä¼šç­‰å¾…ä¸€ä¸ªä»»åŠ¡å®Œæˆåæ‰ç»§ç»­æ‰§è¡Œä¸‹ä¸€ä¸ªä»»åŠ¡ï¼Œè€Œåœ¨å¼‚æ­¥æ“ä½œä¸­ï¼Œä»»åŠ¡å¯ä»¥åœ¨åå°æ‰§è¡Œï¼Œç¨‹åºå¯ä»¥ç»§ç»­æ‰§è¡Œå…¶ä»–ä»»åŠ¡è€Œæ— éœ€ç­‰å¾…å½“å‰ä»»åŠ¡å®Œæˆã€‚

ä½¿ç”¨C++11æä¾›çš„`std::async`å’Œ`std::future`æ¥å®ç°å¼‚æ­¥ä»»åŠ¡ç¤ºä¾‹ï¼š

```cpp
#include <iostream>
#include <future>

// å¼‚æ­¥ä»»åŠ¡
int asyncTask(int input) {
    // æ¨¡æ‹Ÿè€—æ—¶çš„æ“ä½œ
    std::this_thread::sleep_for(std::chrono::seconds(2));

    return input * 2;
}

int main() {
    // å¯åŠ¨å¼‚æ­¥ä»»åŠ¡ï¼Œå¹¶è·å– std::future å¯¹è±¡
    std::future<int> futureResult = std::async(std::launch::async, asyncTask, 5);

    // åœ¨ä¸»çº¿ç¨‹ä¸­è¿›è¡Œå…¶ä»–æ“ä½œ...

    // è·å–å¼‚æ­¥ä»»åŠ¡çš„ç»“æœ
    int result = futureResult.get();

    std::cout << "å¼‚æ­¥ä»»åŠ¡çš„ç»“æœä¸ºï¼š" << result << std::endl;

    return 0;
}

```

æ­¤å¤–ï¼Œè¿˜åŒ…å«memoryå†…å­˜ç®¡ç†åº“ã€threadå¤šçº¿ç¨‹åº“ã€chronoæ—¶é—´åº“ç­‰ã€‚

ä»¥ä¸Šã€‚
