







> 
> ğŸ˜*â˜…,Â°*:.â˜†(ï¿£â–½ï¿£)/$:*.Â°â˜…* ğŸ˜  
>  è¿™ç¯‡æ–‡ç« ä¸»è¦ä»‹ç»åŸºäºnode-media-serveræ­å»ºæµåª’ä½“æœåŠ¡å™¨ç¤ºä¾‹ã€‚  
>  **å­¦å…¶æ‰€ç”¨ï¼Œç”¨å…¶æ‰€å­¦ã€‚â€”â€”æ¢å¯è¶…**  
>  æ¬¢è¿æ¥åˆ°æˆ‘çš„åšå®¢ï¼Œä¸€èµ·å­¦ä¹ ï¼Œå…±åŒè¿›æ­¥ã€‚  
>  å–œæ¬¢çš„æœ‹å‹å¯ä»¥å…³æ³¨ä¸€ä¸‹ï¼Œä¸‹æ¬¡æ›´æ–°ä¸è¿·è·¯ğŸ¥
> 
> 
> 




#### æ–‡ç« ç›®å½•


* + [:smirk:1. node-media-serverä»‹ç»](#smirk1_nodemediaserver_7)
	+ [:blush:2. ç¯å¢ƒå®‰è£…ä¸é…ç½®](#blush2__23)
	+ [:satisfied:3. åº”ç”¨ç¤ºä¾‹](#satisfied3__31)




### ğŸ˜1. node-media-serverä»‹ç»


`node-media-server` æ˜¯ä¸€ä¸ªåŸºäº `Node.js` çš„æµåª’ä½“æœåŠ¡å™¨ï¼Œå®ƒæä¾›äº†æ„å»ºå’Œç®¡ç†å®æ—¶éŸ³è§†é¢‘æµåª’ä½“åº”ç”¨ç¨‹åºæ‰€éœ€çš„åŠŸèƒ½ã€‚å®ƒæ˜¯ä¸€ä¸ªå¼€æºé¡¹ç›®ï¼Œå…·æœ‰çµæ´»æ€§å’Œå¯æ‰©å±•æ€§ï¼Œé€‚ç”¨äºå„ç§æµåª’ä½“åº”ç”¨åœºæ™¯ã€‚


ä»¥ä¸‹æ˜¯ä¸€äº› `node-media-server` çš„ç‰¹ç‚¹å’ŒåŠŸèƒ½ï¼š



> 
> 1.RTMPæ”¯æŒï¼šnode-media-server æ”¯æŒ RTMPï¼ˆReal-Time Messaging Protocolï¼‰åè®®ï¼Œç”¨äºæ¥æ”¶å’Œä¼ è¾“å®æ—¶çš„éŸ³è§†é¢‘æµã€‚RTMP é€‚ç”¨äºå®æ—¶ç›´æ’­å’Œäº’åŠ¨åº”ç”¨ç­‰åœºæ™¯ã€‚
> 
> 
> 



> 
> 2.å¤šè·¯å¹¶å‘æµæ”¯æŒï¼šnode-media-server å…·æœ‰å¤šè·¯å¹¶å‘æµå¤„ç†èƒ½åŠ›ï¼Œå¯ä»¥åŒæ—¶å¤„ç†å¤šä¸ªæµåª’ä½“çš„æ¥æ”¶ã€è½¬ç ã€æ¨æµå’Œå½•åˆ¶ç­‰æ“ä½œã€‚
> 
> 
> 



> 
> 3.é«˜æ€§èƒ½å’Œä½å»¶è¿Ÿï¼šnode-media-server çš„è®¾è®¡æ³¨é‡é«˜æ€§èƒ½å’Œä½å»¶è¿Ÿï¼Œä½¿å…¶é€‚ç”¨äºå®æ—¶åº”ç”¨åœºæ™¯ï¼Œå¦‚å®æ—¶ç›´æ’­ã€äº’åŠ¨ç›´æ’­å’Œè§†é¢‘èŠå¤©ç­‰ã€‚
> 
> 
> 



> 
> 4.æ”¯æŒå¤šç§ç¼–ç æ ¼å¼ï¼šnode-media-server æ”¯æŒå¤šç§å¸¸ç”¨çš„éŸ³è§†é¢‘ç¼–ç æ ¼å¼ï¼Œå¦‚ H.264ã€AACã€VP8 ç­‰ï¼Œä½¿å…¶èƒ½å¤Ÿå¤„ç†ä¸åŒç±»å‹çš„æµåª’ä½“æ•°æ®ã€‚
> 
> 
> 



> 
> 5.åŠŸèƒ½ä¸°å¯Œçš„ APIï¼šnode-media-server æä¾›äº†ä¸°å¯Œçš„ APIï¼Œæ–¹ä¾¿å¼€å‘äººå‘˜è¿›è¡Œé…ç½®å’Œç®¡ç†ã€‚ä½ å¯ä»¥é€šè¿‡ç¼–å†™ä»£ç æ¥å®šåˆ¶å’Œæ‰©å±•æœåŠ¡å™¨çš„åŠŸèƒ½ã€‚
> 
> 
> 



> 
> 6.é«˜åº¦å¯é…ç½®ï¼šnode-media-server å…·æœ‰çµæ´»çš„é…ç½®é€‰é¡¹ï¼Œå…è®¸ä½ æ ¹æ®ç‰¹å®šéœ€æ±‚è¿›è¡Œå®šåˆ¶ã€‚ä½ å¯ä»¥é…ç½®æœåŠ¡å™¨çš„ç«¯å£ã€æµåª’ä½“è·¯å¾„ã€è®¤è¯æ–¹å¼ç­‰ã€‚
> 
> 
> 


### ğŸ˜Š2. ç¯å¢ƒå®‰è£…ä¸é…ç½®



```
# å®‰è£…nodejså’Œffmpeg
sudo apt install nodejs ffmpeg
# å®‰è£…node-media-server
npm install node-media-server

```

### ğŸ˜†3. åº”ç”¨ç¤ºä¾‹


åˆ›å»º`app.js`ï¼Œå†™å…¥ï¼š



```
const NodeMediaServer= require('node-media-server');
const config = {
    rtmp: {
        port: 1935,
        chunk\_size: 60000,
        gop\_cache: true,
        ping: 60,
        ping\_timeout: 30
    },
    http: {
        port: 8000,
        allow\_origin: '\*',
    }
};
 
var nms = new NodeMediaServer(config)
nms.run();

```

è¿è¡Œè¯¥ç¨‹åºï¼š`node app.js`


å‡†å¤‡å¥½ä¸€ä¸ªmp4è§†é¢‘ï¼Œç”¨`ffmpeg`å‘½ä»¤è¡Œæ¨æµï¼ˆä¹Ÿå¯è‡ªå·±å†™ç¨‹åºï¼‰ï¼š



```
ffmpeg -re -i input.mp4 -c:v copy -c:a copy -f flv rtmp://localhost:1935/live/stream_name

```

æœ€åæ•ˆæœç¤ºä¾‹ï¼Œåœ°å€åœ¨`http://localhost:8000/admin/`ï¼š


![åœ¨è¿™é‡Œæ’å…¥å›¾ç‰‡æè¿°](https://img-blog.csdnimg.cn/direct/eba0d4c1b2e94ffb9c7ca615452d86b2.png)


å¦å¤–ï¼Œä¹Ÿå¯ä»¥ç”¨C++ç¨‹åºæ¥å®ç°è§†é¢‘æ¨æµï¼Œä¸‹é¢æ˜¯ä¸€ä¸ªç¤ºä¾‹ï¼š



```
// defer.h
#ifndef FFMPEG\_EXAMPLES\_DEFER\_H
#define FFMPEG\_EXAMPLES\_DEFER\_H

#include <utility>

template<typename F> class defer\_raii
{
public:
    // copy/move construction and any kind of assignment would lead to the cleanup function getting
    // called twice. We can't have that.
    defer\_raii(defer_raii&&)                 = delete;
    defer\_raii(const defer_raii&)            = delete;
    defer_raii& operator=(const defer_raii&) = delete;
    defer_raii& operator=(defer_raii&&)      = delete;

    // construct the object from the given callable
    template<typename FF> defer\_raii(FF&& f) : cleanup\_function(std::forward<FF>(f)) {}

    // when the object goes out of scope call the cleanup function
    ~defer\_raii() { cleanup\_function(); }

private:
    F cleanup_function;
};

template<typename F> defer_raii<F> defer\_func(F&& f) { return { std::forward<F>(f) }; }

#define DEFER\_ACTUALLY\_JOIN(x, y) x##y
#define DEFER\_JOIN(x, y) DEFER\_ACTUALLY\_JOIN(x, y)
#ifdef \_\_COUNTER\_\_
#define DEFER\_UNIQUE\_VARNAME(x) DEFER\_JOIN(x, \_\_COUNTER\_\_)
#else
#define DEFER\_UNIQUE\_VARNAME(x) DEFER\_JOIN(x, \_\_LINE\_\_)
#endif

#define defer(lambda\_\_) \
 [[maybe\_unused]] const auto& DEFER\_UNIQUE\_VARNAME(\_defer\_) = defer\_func([&]() { lambda\_\_; })

#endif // !FFMPEG\_EXAMPLES\_DEFER\_H

```


```
// main.cpp
extern "C" {
#include <libavutil/avutil.h>
#include <libavcodec/avcodec.h>
#include <libavformat/avformat.h>
#include <libavutil/time.h>
}

#define \_\_STDC\_CONSTANT\_MACROS
#include <stdint.h>

#include "defer.h"
// #include "logging.h"
#include <iostream>
#include <chrono>
#include <thread>
#include "fmt/format.h"

int main(int argc, char\* argv[])
{
    // Logger::init(argv[0]);

    if (argc < 3) {
        std::cout << "pushing <input\_video> <rtmp\_name>" << std::endl;
        return -1;
    }

    const char \* in_filename = argv[1];
    const char \* rtmp_name = argv[2];

    AVFormatContext \* decoder_fmt_ctx = nullptr;
    avformat\_open\_input(&decoder_fmt_ctx, in_filename, nullptr, nullptr);
    avformat\_find\_stream\_info(decoder_fmt_ctx, nullptr);

    int video_stream_idx = av\_find\_best\_stream(decoder_fmt_ctx, AVMEDIA_TYPE_VIDEO, -1, -1, nullptr, 0);
    // CHECK(video\_stream\_idx >= 0);

    // decoder
    auto decoder = avcodec\_find\_decoder(decoder_fmt_ctx->streams[video_stream_idx]->codecpar->codec_id);
    // CHECK\_NOTNULL(decoder);

    // decoder context
    AVCodecContext \* decoder_ctx = avcodec\_alloc\_context3(decoder);
    // CHECK\_NOTNULL(decoder\_ctx);

    avcodec\_parameters\_to\_context(decoder_ctx, decoder_fmt_ctx->streams[video_stream_idx]->codecpar);
    avcodec\_open2(decoder_ctx, decoder, nullptr);

    av\_dump\_format(decoder_fmt_ctx, 0, in_filename, 0);

    //
    // output
    //
    AVFormatContext \* encoder_fmt_ctx = nullptr;
    avformat\_alloc\_output\_context2(&encoder_fmt_ctx, nullptr, "flv", nullptr);
    avformat\_new\_stream(encoder_fmt_ctx, nullptr);

    // encoder
    auto encoder = avcodec\_find\_encoder\_by\_name("libx264");
    // CHECK\_NOTNULL(encoder);

    AVCodecContext \*encoder_ctx = avcodec\_alloc\_context3(encoder);
    // CHECK\_NOTNULL(encoder\_ctx);

    AVDictionary\* encoder_options = nullptr;
    av\_dict\_set(&encoder_options, "crf", "23", AV_DICT_DONT_OVERWRITE);
    av\_dict\_set(&encoder_options, "threads", "auto", AV_DICT_DONT_OVERWRITE);
    defer(av\_dict\_free(&encoder_options));

    // encoder codec params
    encoder_ctx->height = decoder_ctx->height;
    encoder_ctx->width = decoder_ctx->width;
    encoder_ctx->pix_fmt = decoder_ctx->pix_fmt;
    encoder_ctx->sample_aspect_ratio = decoder_ctx->sample_aspect_ratio;
    encoder_ctx->framerate = av\_guess\_frame\_rate(decoder_fmt_ctx, decoder_fmt_ctx->streams[video_stream_idx], nullptr);

    // time base
    encoder_ctx->time_base = av\_inv\_q(encoder_ctx->framerate);
    encoder_fmt_ctx->streams[0]->time_base = encoder_ctx->time_base;

    avcodec\_open2(encoder_ctx, encoder, &encoder_options);
    avcodec\_parameters\_from\_context(encoder_fmt_ctx->streams[0]->codecpar, encoder_ctx);

    if (!(encoder_fmt_ctx->oformat->flags & AVFMT_NOFILE)) {
        avio\_open(&encoder_fmt_ctx->pb, rtmp_name, AVIO_FLAG_WRITE);
    }

    avformat\_write\_header(encoder_fmt_ctx, nullptr);

    av\_dump\_format(encoder_fmt_ctx, 0, rtmp_name, 1);

    AVPacket \* in_packet = av\_packet\_alloc();
    defer(av\_packet\_free(&in_packet));
    AVPacket \* out_packet = av\_packet\_alloc();
    defer(av\_packet\_free(&out_packet));
    AVFrame \* in_frame = av\_frame\_alloc();
    defer(av\_frame\_free(&in_frame));

    int64\_t first_pts = AV_NOPTS_VALUE;

    while(av\_read\_frame(decoder_fmt_ctx, in_packet) >= 0) {
        if (in_packet->stream_index != video_stream_idx) {
            continue;
        }

        int ret = avcodec\_send\_packet(decoder_ctx, in_packet);
        while(ret >= 0) {
            av\_frame\_unref(in_frame);
            ret = avcodec\_receive\_frame(decoder_ctx, in_frame);
            if (ret == AVERROR(EAGAIN) || ret == AVERROR_EOF) {
                break;
            } else if (ret < 0) {
                std::cout << "[PUSHING] avcodec\_receive\_frame()";
                return ret;
            }

            in_frame->pict_type = AV_PICTURE_TYPE_NONE;

            // sleep @{
            first_pts = first_pts == AV_NOPTS_VALUE ? av\_gettime\_relative() : first_pts;

            int64\_t ts = av\_gettime\_relative() - first_pts;

            int64\_t pts_us = av\_rescale\_q(in_frame->pts, encoder_fmt_ctx->streams[0]->time_base, { 1, AV_TIME_BASE });
            int64\_t sleep_us = std::max<int64\_t>(0, pts_us - ts);

            std::cout << fmt::format("[PUSHING] pts = {:>6.3f}s, ts = {:>6.3f}s, sleep = {:>4d}ms, frame = {:>5d}, fps = {:>5.2f}",
                                     pts_us / 1000000.0, ts / 1000000.0, sleep_us / 1000,
                                     encoder_ctx->frame_number, encoder_ctx->frame_number / (ts / 1000000.0));
            av\_usleep(sleep_us);
            std::this_thread::sleep\_for(std::chrono::milliseconds(10));
            // @}

            ret = avcodec\_send\_frame(encoder_ctx, in_frame);
            while(ret >= 0) {
                av\_packet\_unref(out_packet);
                ret = avcodec\_receive\_packet(encoder_ctx, out_packet);

                if(ret == AVERROR(EAGAIN)) {
                    break;
                } else if(ret == AVERROR_EOF) {
                    std::cout << "[PUSHING] EOF";
                    break;
                } else if(ret < 0) {
                    std::cout << "[PUSHING] avcodec\_receive\_packet()";
                    return ret;
                }

                out_packet->stream_index = 0;
                av\_packet\_rescale\_ts(out_packet, decoder_fmt_ctx->streams[video_stream_idx]->time_base, encoder_fmt_ctx->streams[0]->time_base);

                if (av\_interleaved\_write\_frame(encoder_fmt_ctx, out_packet) != 0) {
                    std::cout <<"[PUSHING] av\_interleaved\_write\_frame()";
                    return -1;
                }
            }
        }
        av\_packet\_unref(in_packet);
    }

    avformat\_close\_input(&decoder_fmt_ctx);
    avformat\_free\_context(encoder_fmt_ctx);

    avcodec\_free\_context(&decoder_ctx);
    avcodec\_free\_context(&encoder_ctx);

    return 0;
}

```

ç¼–è¯‘ä¸è¿è¡Œï¼š



```
g++ -o main main.cpp -lavformat -lavcodec -lavutil -lfmt -D\_\_STDC\_CONSTANT\_MACROS
./main test.mp4 rtmp://127.0.0.1:1935/live/test
# è¿˜ä¸å¤ªå®Œå–„ï¼Œå¯æ”¹è¿›

```

![è¯·æ·»åŠ å›¾ç‰‡æè¿°](https://img-blog.csdnimg.cn/5ea93bb657184b9eb8515cc76047c16a.png)


ä»¥ä¸Šã€‚





