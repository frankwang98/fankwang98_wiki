







> 
> ğŸ˜*â˜…,Â°*:.â˜†(ï¿£â–½ï¿£)/$:*.Â°â˜…* ğŸ˜  
>  è¿™ç¯‡æ–‡ç« ä¸»è¦ä»‹ç»Windowså›¾å½¢åº“EasyXé…ç½®ä¸ä½¿ç”¨ã€‚  
>  **æ— ä¸“ç²¾åˆ™ä¸èƒ½æˆï¼Œæ— æ¶‰çŒåˆ™ä¸èƒ½é€šã€‚â€”â€”æ¢å¯è¶…**  
>  æ¬¢è¿æ¥åˆ°æˆ‘çš„åšå®¢ï¼Œä¸€èµ·å­¦ä¹ ï¼Œå…±åŒè¿›æ­¥ã€‚  
>  å–œæ¬¢çš„æœ‹å‹å¯ä»¥å…³æ³¨ä¸€ä¸‹ï¼Œä¸‹æ¬¡æ›´æ–°ä¸è¿·è·¯ğŸ¥
> 
> 
> 




#### æ–‡ç« ç›®å½•


* + [:smirk:1. é¡¹ç›®ä»‹ç»](#smirk1__7)
	+ [:blush:2. ç¯å¢ƒé…ç½®](#blush2__21)
	+ [:satisfied:3. ä½¿ç”¨è¯´æ˜](#satisfied3__39)
	+ - [çª—å£ç»˜åˆ¶åœ†çš„ç¤ºä¾‹ï¼š](#_41)
		- [è·å–é¼ æ ‡å’Œé”®ç›˜äº‹ä»¶ç¤ºä¾‹ï¼š](#_60)
		- [é¼ æ ‡æ“ä½œä¸ç»˜åˆ¶ç¤ºä¾‹ï¼š](#_114)
		- [è´ªåƒè›‡ç¤ºä¾‹ï¼š](#_160)




### ğŸ˜1. é¡¹ç›®ä»‹ç»


å®˜ç½‘ï¼š`https://easyx.cn/`


`EasyX`æ˜¯ä¸€ä¸ªåŸºäº`Windows`çš„ç®€å•å›¾å½¢åº“ï¼Œå®ƒæä¾›äº†ä¸€ä¸ªæ˜“äºä½¿ç”¨çš„å›¾å½¢ç»˜åˆ¶æ¥å£ï¼Œé€‚ç”¨äºåˆå­¦è€…å’Œçˆ±å¥½è€…è¿›è¡Œå›¾å½¢ç¼–ç¨‹ã€‚ä¸‹é¢æ˜¯`EasyX`åº“çš„ä¸€äº›ç‰¹ç‚¹å’ŒåŠŸèƒ½ï¼š



> 
> 1.æ˜“äºå­¦ä¹ å’Œä½¿ç”¨ï¼šEasyXé‡‡ç”¨äº†ç®€å•çš„å›¾å½¢ç»˜åˆ¶æ¥å£ï¼Œä½¿å¾—åˆå­¦è€…å¯ä»¥å¿«é€Ÿä¸Šæ‰‹ã€‚å®ƒæä¾›äº†ä¸€äº›åŸºæœ¬çš„ç»˜å›¾å‡½æ•°ï¼Œå¦‚ç”»çº¿ã€ç”»åœ†ã€ç»˜åˆ¶æ–‡æœ¬ç­‰ï¼Œä½¿ç”¨æˆ·èƒ½å¤Ÿè½»æ¾åˆ›å»ºå›¾å½¢ç•Œé¢å’ŒåŠ¨ç”»æ•ˆæœã€‚
> 
> 
> 



> 
> 2.è½»é‡çº§å’Œå¿«é€Ÿï¼šEasyXæ˜¯ä¸€ä¸ªè½»é‡çº§çš„å›¾å½¢åº“ï¼Œä¸éœ€è¦å¤æ‚çš„å®‰è£…å’Œé…ç½®è¿‡ç¨‹ã€‚å®ƒä½¿ç”¨GDIï¼ˆå›¾å½¢è®¾å¤‡æ¥å£ï¼‰æ¥è¿›è¡Œå›¾å½¢ç»˜åˆ¶ï¼Œå…·æœ‰è¾ƒå¿«çš„ç»˜å›¾é€Ÿåº¦å’Œç›¸å¯¹è¾ƒä½çš„ç³»ç»Ÿèµ„æºå ç”¨ã€‚
> 
> 
> 



> 
> 3.å›¾å½¢ç•Œé¢è®¾è®¡ï¼šEasyXæä¾›äº†ä¸€äº›å¸¸ç”¨çš„å›¾å½¢ç•Œé¢æ§ä»¶ï¼Œå¦‚æŒ‰é’®ã€æ–‡æœ¬æ¡†ã€æ»šåŠ¨æ¡ç­‰ï¼Œä½¿ç”¨æˆ·å¯ä»¥è½»æ¾åˆ›å»ºäº¤äº’å¼çš„å›¾å½¢ç•Œé¢ã€‚
> 
> 
> 



> 
> 4.åŠ¨ç”»å’Œæ¸¸æˆå¼€å‘ï¼šEasyXæ”¯æŒå®æ—¶åŠ¨ç”»å’Œæ¸¸æˆå¼€å‘ï¼Œæä¾›äº†å¸§åŠ¨ç”»ã€åŒç¼“å†²æŠ€æœ¯ç­‰åŠŸèƒ½ï¼Œä½¿ç”¨æˆ·èƒ½å¤Ÿåˆ›å»ºæµç•…çš„åŠ¨ç”»æ•ˆæœå’Œç®€å•çš„æ¸¸æˆã€‚
> 
> 
> 



> 
> 5.è·¨å¹³å°ï¼šEasyXä¸»è¦é’ˆå¯¹Windowså¹³å°ï¼Œæ”¯æŒWindows XPåŠä»¥ä¸Šç‰ˆæœ¬ã€‚ç„¶è€Œï¼ŒEasyXä¹Ÿå¯ä»¥åœ¨éƒ¨åˆ†Linuxç¯å¢ƒä¸‹ä½¿ç”¨ï¼Œå¦‚Wineæ¨¡æ‹Ÿå™¨ã€‚
> 
> 
> 


### ğŸ˜Š2. ç¯å¢ƒé…ç½®


æˆ‘è¿™é‡Œç”¨çš„`Clion + mingw`ï¼ŒEasyXçš„ä¸‹è½½åœ°å€ï¼š`https://easyx.cn/download/easyx4mingw_20220901.zip`


CMakeLists.txtç¤ºä¾‹ï¼š



```
cmake_minimum_required(VERSION 3.19)
project(easyx_demo)

set(CMAKE_CXX_STANDARD 14)

include_directories("D:/develop/easyx4mingw\_20220901/include")
link_directories("D:/develop/easyx4mingw\_20220901/lib64")

add_executable(easyx_demo main.cpp)
target_link_libraries(easyx_demo -leasyx)

```

### ğŸ˜†3. ä½¿ç”¨è¯´æ˜


å®˜ç½‘ä¹Ÿæä¾›äº†å‡½æ•°ä½¿ç”¨çš„æ–‡æ¡£ï¼Œå¹¶ç»™å‡ºäº†ä¸€äº›ç¤ºä¾‹ï¼š`https://docs.easyx.cn/zh-cn/char-matrix`


#### çª—å£ç»˜åˆ¶åœ†çš„ç¤ºä¾‹ï¼š



```
#include <graphics.h>
#include <conio.h>

int main()
{
    initgraph(640, 480);  // åˆ›å»ºä¸€ä¸ª640x480çš„ç»˜å›¾çª—å£

    circle(320, 240, 100);  // åœ¨çª—å£ä¸­å¿ƒç”»ä¸€ä¸ªåŠå¾„ä¸º100çš„åœ†

    getch();  // ç­‰å¾…ç”¨æˆ·æŒ‰ä¸‹ä»»æ„é”®

    closegraph();  // å…³é—­ç»˜å›¾çª—å£
    return 0;
}

```

#### è·å–é¼ æ ‡å’Œé”®ç›˜äº‹ä»¶ç¤ºä¾‹ï¼š



```
#include <graphics.h>
#include <conio.h>
#include <stdio.h>

int main()
{
    initgraph(640, 480);  // åˆ›å»ºä¸€ä¸ª640x480çš„ç»˜å›¾çª—å£

    while (true)
    {
        // ç›‘å¬é”®ç›˜äº‹ä»¶
        if (kbhit())
        {
            char ch = getch();  // è·å–é”®ç›˜æŒ‰é”®
            if (ch == 'q' || ch == 'Q')
                break;  // å¦‚æœæŒ‰ä¸‹äº†Qé”®ï¼Œé€€å‡ºå¾ªç¯
        }

        // ç›‘å¬é¼ æ ‡äº‹ä»¶
        if (MouseHit())
        {
            MOUSEMSG mouseMsg = GetMouseMsg();

            if (mouseMsg.uMsg == WM_MOUSEMOVE)
            {
                int x = mouseMsg.x;
                int y = mouseMsg.y;
                // åœ¨æ§åˆ¶å°è¾“å‡ºé¼ æ ‡ç§»åŠ¨çš„åæ ‡
                printf("Mouse move: x = %d, y = %d\n", x, y);
            }
            else if (mouseMsg.uMsg == WM_LBUTTONDOWN)
            {
                int x = mouseMsg.x;
                int y = mouseMsg.y;
                // åœ¨æ§åˆ¶å°è¾“å‡ºé¼ æ ‡å·¦é”®æŒ‰ä¸‹çš„åæ ‡
                printf("Left button down: x = %d, y = %d\n", x, y);
            }
            else if (mouseMsg.uMsg == WM_LBUTTONUP)
            {
                int x = mouseMsg.x;
                int y = mouseMsg.y;
                // åœ¨æ§åˆ¶å°è¾“å‡ºé¼ æ ‡å·¦é”®é‡Šæ”¾çš„åæ ‡
                printf("Left button up: x = %d, y = %d\n", x, y);
            }
        }
    }

    closegraph();  // å…³é—­ç»˜å›¾çª—å£
    return 0;
}

```

#### é¼ æ ‡æ“ä½œä¸ç»˜åˆ¶ç¤ºä¾‹ï¼š



```
#include <graphics.h>

int main()
{
    // åˆå§‹åŒ–å›¾å½¢çª—å£
    initgraph(640, 480);

    ExMessage m;		// å®šä¹‰æ¶ˆæ¯å˜é‡

    while(true)
    {
        // è·å–ä¸€æ¡é¼ æ ‡æˆ–æŒ‰é”®æ¶ˆæ¯
        m = getmessage(EX_MOUSE | EX_KEY);

        switch(m.message)
        {
            case WM_MOUSEMOVE:
                // é¼ æ ‡ç§»åŠ¨çš„æ—¶å€™ç”»çº¢è‰²çš„å°ç‚¹
                putpixel(m.x, m.y, RED);
                break;

            case WM_LBUTTONDOWN:
                // å¦‚æœç‚¹å·¦é”®çš„åŒæ—¶æŒ‰ä¸‹äº† Ctrl é”®
                if (m.ctrl)
                    // ç”»ä¸€ä¸ªå¤§æ–¹å—
                    rectangle(m.x - 10, m.y - 10, m.x + 10, m.y + 10);
                else
                    // ç”»ä¸€ä¸ªå°æ–¹å—
                    rectangle(m.x - 5, m.y - 5, m.x + 5, m.y + 5);
                break;

            case WM_KEYDOWN:
                if (m.vkcode == VK_ESCAPE)
                    return 0;	// æŒ‰ ESC é”®é€€å‡ºç¨‹åº
        }
    }

    // å…³é—­å›¾å½¢çª—å£
    closegraph();
    return 0;
}

```

#### è´ªåƒè›‡ç¤ºä¾‹ï¼š



```
#include <graphics.h>
#include <conio.h>
#include <time.h>

const int CELL_SIZE = 20;  // æ¯ä¸ªå•å…ƒæ ¼çš„å°ºå¯¸
const int WIDTH = 800;  // çª—å£å®½åº¦
const int HEIGHT = 600;  // çª—å£é«˜åº¦
const int ROWS = HEIGHT / CELL_SIZE;  // è¡Œæ•°
const int COLS = WIDTH / CELL_SIZE;  // åˆ—æ•°

struct Point  // åæ ‡ç‚¹ç»“æ„ä½“
{
    int x, y;
};

enum Direction  // ç§»åŠ¨æ–¹å‘æšä¸¾
{
    UP,
    DOWN,
    LEFT,
    RIGHT
};

void DrawCell(int x, int y, COLORREF color)
{
    setfillcolor(color);
    setlinecolor(color);
    fillrectangle(x \* CELL_SIZE, y \* CELL_SIZE, (x + 1) \* CELL_SIZE, (y + 1) \* CELL_SIZE);
}

void DrawSnake(Point\* snake, int length)
{
    for (int i = 0; i < length; i++)
    {
        if (i == 0)
            DrawCell(snake[i].x, snake[i].y, RGB(0, 255, 0));  // ç»˜åˆ¶è›‡å¤´
        else
            DrawCell(snake[i].x, snake[i].y, RGB(0, 200, 0));  // ç»˜åˆ¶è›‡èº«
    }
}

void GenerateFood(Point\* snake, int length, Point& food)
{
    while (true)
    {
        food.x = rand() % COLS;
        food.y = rand() % ROWS;

        bool overlap = false;
        for (int i = 0; i < length; i++)
        {
            if (snake[i].x == food.x && snake[i].y == food.y)
            {
                overlap = true;
                break;
            }
        }

        if (!overlap)
            break;
    }

    DrawCell(food.x, food.y, RGB(255, 0, 0));  // ç»˜åˆ¶é£Ÿç‰©
}

void UpdateSnake(Point\* snake, int& length, Direction direction, bool& gameOver)
{
    Point head = snake[0];
    Point newHead = head;

    switch (direction)
    {
        case UP:
            newHead.y--;
            break;
        case DOWN:
            newHead.y++;
            break;
        case LEFT:
            newHead.x--;
            break;
        case RIGHT:
            newHead.x++;
            break;
    }

    if (newHead.x < 0 || newHead.x >= COLS || newHead.y < 0 || newHead.y >= ROWS)
    {
        gameOver = true;  // è¶Šç•Œï¼Œæ¸¸æˆç»“æŸ
        return;
    }

    for (int i = length - 1; i > 0; i--)
    {
        snake[i] = snake[i - 1];
    }

    snake[0] = newHead;

    for (int i = 1; i < length; i++)
    {
        if (snake[i].x == newHead.x && snake[i].y == newHead.y)
        {
            gameOver = true;  // æ’åˆ°è‡ªå·±ï¼Œæ¸¸æˆç»“æŸ
            return;
        }
    }
}

int main()
{
    initgraph(WIDTH, HEIGHT);  // åˆ›å»ºä¸€ä¸ªæŒ‡å®šå®½é«˜çš„ç»˜å›¾çª—å£

    srand(static\_cast<unsigned int>(time(nullptr)));  // åˆå§‹åŒ–éšæœºæ•°ç§å­

    Point\* snake = new Point[ROWS \* COLS];  // è›‡çš„åæ ‡æ•°ç»„
    int length = 1;  // è›‡çš„åˆå§‹é•¿åº¦
    Direction direction = RIGHT;  // è›‡çš„åˆå§‹ç§»åŠ¨æ–¹å‘
    bool gameOver = false;  // æ¸¸æˆæ˜¯å¦ç»“æŸ

    // åˆå§‹åŒ–è›‡çš„åˆå§‹ä½ç½®
    snake[0].x = COLS / 2;
    snake[0].y = ROWS / 2;

    Point food;  // é£Ÿç‰©çš„åæ ‡

    GenerateFood(snake, length, food);  // ç”Ÿæˆé£Ÿç‰©

    while (!gameOver)
    {
        // ç›‘å¬é”®ç›˜äº‹ä»¶
        if (kbhit())
        {
            char ch = getch();
            switch (ch)
            {
                case 'W':
                case 'w':
                    if(direction != DOWN)
                        direction = UP;
                    break;
                case 'S':
                case 's':
                    if (direction != UP)
                        direction = DOWN;
                    break;
                case 'A':
                case 'a':
                    if (direction != RIGHT)
                        direction = LEFT;
                    break;
                case 'D':
                case 'd':
                    if (direction != LEFT)
                        direction = RIGHT;
                    break;
            }
        }

        cleardevice();  // æ¸…ç©ºç»˜å›¾çª—å£

        UpdateSnake(snake, length, direction, gameOver);  // æ›´æ–°è›‡çš„ä½ç½®

        if (snake[0].x == food.x && snake[0].y == food.y)
        {
            length++;  // è›‡åƒåˆ°é£Ÿç‰©ï¼Œé•¿åº¦å¢åŠ 
            GenerateFood(snake, length, food);  // ç”Ÿæˆæ–°çš„é£Ÿç‰©
        }

        DrawSnake(snake, length);  // ç»˜åˆ¶è›‡

        DrawCell(food.x, food.y, RGB(255, 0, 0));  // ç»˜åˆ¶é£Ÿç‰©

        Sleep(100);
    }

    delete[] snake;  // é‡Šæ”¾å†…å­˜

    closegraph();  // å…³é—­ç»˜å›¾çª—å£

    return 0;
}

```

![åœ¨è¿™é‡Œæ’å…¥å›¾ç‰‡æè¿°](https://img-blog.csdnimg.cn/6cbcd6c17cec4dba9bb3c0f895f02fa2.png)


ä»¥ä¸Šã€‚





