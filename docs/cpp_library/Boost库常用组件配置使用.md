### ğŸ˜1. Booståº“ä»‹ç»

é¡¹ç›®Githubåœ°å€ï¼š`https://github.com/boostorg/boost`

Booståº“åœ¨çº¿ä¹¦ç±ï¼š`https://wizardforcel.gitbooks.io/the-boost-cpp-libraries/content/0.html`

Boostæ˜¯ä¸€ä¸ªæµè¡Œçš„ã€å¼€æºçš„C++åº“é›†åˆï¼Œæä¾›äº†å„ç§åŠŸèƒ½å¼ºå¤§çš„åº“å’Œå·¥å…·ï¼Œæ‰©å±•äº†C++è¯­è¨€çš„èƒ½åŠ›ï¼Œå¹¶ä¸ºå¼€å‘è€…æä¾›äº†æ›´é«˜çº§åˆ«çš„æŠ½è±¡å’Œå·¥å…·ã€‚Booståº“ç»è¿‡å¹¿æ³›çš„ä½¿ç”¨å’Œæµ‹è¯•ï¼Œè¢«è®¤ä¸ºæ˜¯C++ç¤¾åŒºçš„äº‹å®æ ‡å‡†ä¹‹ä¸€ã€‚

Booståº“åŒ…å«äº†å¤šä¸ªæ¨¡å—ï¼Œæ¯ä¸ªæ¨¡å—éƒ½æä¾›äº†ä¸åŒé¢†åŸŸçš„åŠŸèƒ½å’Œå·¥å…·ï¼Œè¦†ç›–äº†è¯¸å¦‚å­—ç¬¦ä¸²æ“ä½œã€æ•°æ®ç»“æ„ã€ç®—æ³•ã€æ—¥æœŸæ—¶é—´å¤„ç†ã€æ–‡ä»¶ç³»ç»Ÿã€çº¿ç¨‹ã€ç½‘ç»œã€æ­£åˆ™è¡¨è¾¾å¼ç­‰å„ä¸ªæ–¹é¢ã€‚ä»¥ä¸‹æ˜¯ä¸€äº›å¸¸ç”¨çš„Booståº“ï¼š

> 1.Boost.Asioï¼šæä¾›äº†å¼‚æ­¥I/Oæ“ä½œçš„ç½‘ç»œç¼–ç¨‹åº“ï¼Œæ”¯æŒTCPã€UDPã€ä¸²å£ç­‰ç½‘ç»œåè®®ã€‚

> 2.Boost.Smart_Ptrï¼šæä¾›äº†æ™ºèƒ½æŒ‡é’ˆç±»ï¼Œå¦‚shared_ptrå’Œweak_ptrï¼Œç”¨äºæ–¹ä¾¿åœ°è¿›è¡Œå†…å­˜ç®¡ç†ã€‚

> 3.Boost.Filesystemï¼šæä¾›äº†å¯¹æ–‡ä»¶ç³»ç»Ÿçš„è®¿é—®å’Œæ“ä½œï¼ŒåŒ…æ‹¬æ–‡ä»¶å’Œç›®å½•çš„åˆ›å»ºã€åˆ é™¤ã€éå†ç­‰ã€‚

> 4.Boost.Regexï¼šæä¾›äº†æ­£åˆ™è¡¨è¾¾å¼çš„åŠŸèƒ½ï¼Œç”¨äºè¿›è¡Œæ–‡æœ¬åŒ¹é…å’Œæœç´¢æ“ä½œã€‚

> 5.Boost.Threadï¼šæä¾›äº†è·¨å¹³å°çš„å¤šçº¿ç¨‹ç¼–ç¨‹æ¥å£ï¼Œç®€åŒ–äº†çº¿ç¨‹çš„åˆ›å»ºã€åŒæ­¥å’Œé€šä¿¡ç­‰æ“ä½œã€‚

> 6.Boost.Serializationï¼šæä¾›äº†å¯¹è±¡çš„åºåˆ—åŒ–å’Œååºåˆ—åŒ–åŠŸèƒ½ï¼Œå¯ä»¥å°†å¯¹è±¡ä»¥äºŒè¿›åˆ¶æˆ–XMLæ ¼å¼è¿›è¡Œå­˜å‚¨å’Œä¼ è¾“ã€‚

é™¤äº†ä»¥ä¸Šåˆ—ä¸¾çš„åº“ä¹‹å¤–ï¼ŒBoostè¿˜åŒ…å«äº†è®¸å¤šå…¶ä»–åŠŸèƒ½ä¸°å¯Œçš„åº“ï¼Œå¦‚Boost.Mathç”¨äºæ•°å­¦è®¡ç®—ã€Boost.Graphç”¨äºå›¾è®ºç®—æ³•ã€Boost.Testç”¨äºå•å…ƒæµ‹è¯•ç­‰ã€‚Booståº“é€šå¸¸ä»¥å¤´æ–‡ä»¶æ–¹å¼æä¾›ï¼Œä½¿ç”¨Booståªéœ€åŒ…å«ç›¸åº”çš„å¤´æ–‡ä»¶ï¼Œå¹¶é“¾æ¥å¯¹åº”çš„åº“æ–‡ä»¶ã€‚

Booståº“çš„ç›®æ ‡æ˜¯æä¾›é«˜è´¨é‡å’Œé«˜å¯ç§»æ¤æ€§çš„C++ä»£ç ï¼Œå› æ­¤å®ƒçš„ä»£ç è´¨é‡å¾ˆé«˜ï¼Œå¹¶ä¸”æ”¯æŒå„ç§ä¸»æµæ“ä½œç³»ç»Ÿå’Œç¼–è¯‘å™¨ã€‚Booståº“çš„å¼€å‘æ˜¯ä¸€ä¸ªå¼€æ”¾çš„ç¤¾åŒºé©±åŠ¨è¿‡ç¨‹ï¼Œæ¥å—ç”¨æˆ·çš„åé¦ˆå’Œè´¡çŒ®ï¼Œå¹¶å®šæœŸå‘å¸ƒæ–°ç‰ˆæœ¬ã€‚

### ğŸ˜Š2. ç¯å¢ƒé…ç½®

ä¸‹é¢è¿›è¡Œç¯å¢ƒé…ç½®ï¼š

```sh
# aptå®‰è£…å¸¸ç”¨æ¨¡å—
sudo apt-get install libboost-dev

# Boost.Geometryåªåœ¨boost1.75ä»¥ä¸Šæ”¯æŒ
wget https://dl.bintray.com/boostorg/release/1.76.0/source/boost_1_76_0.tar.gz
tar -xzvf boost_1_76_0.tar.gz
cd boost_1_76_0
./bootstrap.sh --prefix=/usr/local
sudo ./b2 install
sudo apt install libboost-all-dev
# éªŒè¯é«˜ç‰ˆæœ¬å®‰è£…
ls /usr/local/include/boost/geometry/
```

### Boost.Threadä½¿ç”¨ç¤ºä¾‹

åˆ›å»ºçº¿ç¨‹ç¤ºä¾‹ï¼š

```cpp
#include <iostream>
#include <boost/thread.hpp>

// çº¿ç¨‹å‡½æ•°
void threadFunction()
{
    // è¾“å‡ºçº¿ç¨‹ç›¸å…³ä¿¡æ¯
    std::cout << "Thread ID: " << boost::this_thread::get_id() << std::endl;
    std::cout << "Hello from a thread!" << std::endl;
}

int main()
{
    // åˆ›å»ºçº¿ç¨‹å¹¶å¯åŠ¨
    boost::thread threadObj(threadFunction);
    // å¤šä¸ªçº¿ç¨‹ç±»ä¼¼

    // ç­‰å¾…çº¿ç¨‹ç»“æŸ
    threadObj.join();

    // è¾“å‡ºä¸»çº¿ç¨‹ç›¸å…³ä¿¡æ¯
    std::cout << "Thread ID: " << boost::this_thread::get_id() << std::endl;
    std::cout << "Main thread exiting..." << std::endl;

    return 0;
}

```

ç¼–è¯‘è¿è¡Œï¼š

```sh
g++ -o main main.cpp -lboost_thread -lpthread
./main
Thread ID: 7f65d8552700
Hello from a thread!
Thread ID: 7f65d8553740
Main thread exiting...

```

### Boost.Serializationä½¿ç”¨ç¤ºä¾‹

```cpp
#include <iostream>
#include <fstream>
#include <boost/archive/text_oarchive.hpp>
#include <boost/archive/text_iarchive.hpp>

// è¦è¿›è¡Œåºåˆ—åŒ–å’Œååºåˆ—åŒ–çš„ç¤ºä¾‹ç±»
class MyClass
{
public:
    int data;
    double d;
    std::string str;

    // å£°æ˜ Boost åºåˆ—åŒ–å‡½æ•°ä¸ºå‹å…ƒå‡½æ•°
    friend class boost::serialization::access;

    // Boost åºåˆ—åŒ–å‡½æ•°ï¼ˆå°†å¯¹è±¡è½¬æ¢ä¸ºå­—èŠ‚æµï¼‰
    template<class Archive>
    void serialize(Archive & ar, const unsigned int version)
    {
        ar & data;
        ar & d;
        ar & str;
    }
};

int main()
{
    // åˆ›å»ºä¸€ä¸ª MyClass å¯¹è±¡å¹¶è®¾ç½®æ•°æ®
    MyClass obj;
    obj.data = 42;
    obj.d = 1.005;
    obj.str = "hello";

    // å°†å¯¹è±¡åºåˆ—åŒ–åˆ°æ–‡ä»¶
    std::ofstream outputFile("data.txt");
    boost::archive::text_oarchive outputArchive(outputFile);
    outputArchive << obj;
    outputFile.close();

    // ä»æ–‡ä»¶ä¸­ååºåˆ—åŒ–å¯¹è±¡
    std::ifstream inputFile("data.txt");
    boost::archive::text_iarchive inputArchive(inputFile);
    MyClass restoredObj;
    inputArchive >> restoredObj;
    inputFile.close();

    // è¾“å‡ºååºåˆ—åŒ–åçš„å¯¹è±¡æ•°æ®
    std::cout << "Restored data: " << restoredObj.data << std::endl;
    std::cout << "Restored d: " << restoredObj.d << std::endl;
    std::cout << "Restored str: " << restoredObj.str << std::endl;

    return 0;
}

```

ç¼–è¯‘è¿è¡Œï¼š

```sh
g++ -o main main.cpp -lboost_serialization && ./main
Restored data: 42
Restored d: 1.005
Restored str: hello

```

### Boost.Mathä½¿ç”¨ç¤ºä¾‹

```cpp
#include <iostream>
#include <boost/math/constants/constants.hpp>
#include <boost/math/special_functions/bessel.hpp>

int main()
{
    // è®¡ç®—åœ†å‘¨ç‡
    double pi = boost::math::constants::pi<double>();
    std::cout << "Pi: " << pi << std::endl;

    // è´å¡å°”å‡½æ•°
    double besselJ0 = boost::math::cyl_bessel_j(0, 2.0);
    std::cout << "Bessel J0(2.0): " << besselJ0 << std::endl;

    return 0;
}

```

ç¼–è¯‘è¿è¡Œï¼š

```sh
g++ -o main main.cpp -lboost_math_c99 -lboost_math_c99f && ./main
Pi: 3.14159
Bessel J0(2.0): 0.223891

```

### Boost.Timeä½¿ç”¨ç¤ºä¾‹

```cpp
#include <iostream>
#include <boost/date_time/posix_time/posix_time.hpp>

long GetTime();

int main()
{
    // è·å–å½“å‰ç³»ç»Ÿæ—¶é—´
    boost::posix_time::ptime now = boost::posix_time::second_clock::local_time();
    std::cout << "Current system time: " << now << std::endl;
   
    // æ ¼å¼åŒ–è¾“å‡ºå½“å‰ç³»ç»Ÿæ—¶é—´
    std::string formattedTime = boost::posix_time::to_simple_string(now);
    std::cout << "Formatted current system time: " << formattedTime << std::endl;
   
    // æ—¥æœŸå¢å‡
    boost::posix_time::ptime tomorrow = now + boost::gregorian::days(1);
    std::cout << "Tomorrow: " << tomorrow << std::endl;
   
    // æ—¶é—´å¢å‡
    boost::posix_time::ptime nextHour = now + boost::posix_time::hours(1);
    std::cout << "Next hour: " << nextHour << std::endl;

    // æ—¶é—´å·®è®¡ç®—
    boost::posix_time::time_duration diff = nextHour - now;
    std::cout << "Difference between now and next hour: " << diff.total_seconds() << " seconds" << std::endl;

    // è·å–å½“å‰ç³»ç»Ÿæ—¶é—´ï¼Œç²¾ç¡®åˆ°æ¯«ç§’
    boost::posix_time::ptime now_ms = boost::posix_time::microsec_clock::local_time();
    // å°†æ—¶é—´è½¬æ¢ä¸ºæ¯«ç§’
    boost::posix_time::time_duration duration = now_ms.time_of_day();
    long milliseconds = duration.total_milliseconds();
    // è¾“å‡ºæ¯«ç§’çº§æ—¶é—´
    std::cout << "Current system milliseconds: " << milliseconds << std::endl;

    long t1 = GetTime();
    sleep(1);
    long t2 = GetTime();
    // è¾“å‡ºæ—¶é—´å·®
    std::cout << "This program cost: " << t2 - t1 << std::endl;

    return 0;
}

long GetTime()
{
    boost::posix_time::ptime now_ms = boost::posix_time::microsec_clock::local_time();
    boost::posix_time::time_duration duration = now_ms.time_of_day();
    long milliseconds = duration.total_milliseconds();
    return milliseconds;
}

```

ç¼–è¯‘è¿è¡Œï¼š

```sh
g++ -o main main.cpp -lboost_date_time && ./main
28 16:52:31
Tomorrow: 2023-Jul-29 16:52:31
Next hour: 2023-Jul-28 17:52:31
Difference between now and next hour: 3600 seconds
Current system milliseconds: 60751420
This program cost: 1000

```

### Boost.Geometryä½¿ç”¨ç¤ºä¾‹

```cpp
// è®¡ç®—ä¸¤ç‚¹é—´è·ç¦» -lboost_system -lboost_geometry
#include <iostream>
#include <boost/geometry.hpp>
#include <boost/geometry/geometries/register/point.hpp>

namespace bg = boost::geometry;

// å®šä¹‰ä¸€ä¸ª Point ç»“æ„ä½“ï¼Œå¹¶æ³¨å†Œä¸º Boost.Geometry çš„ç‚¹ç±»å‹
struct Point
{
    double x, y;
};

BOOST_GEOMETRY_REGISTER_POINT_2D(Point, double, bg::cs::cartesian, x, y)

int main()
{
    // åˆ›å»ºä¸¤ä¸ªç‚¹
    Point p1{0.0, 0.0};
    Point p2{1.0, 1.0};

    // è®¡ç®—ä¸¤ä¸ªç‚¹ä¹‹é—´çš„æ¬§å‡ é‡Œå¾—è·ç¦»
    double distance = bg::distance(p1, p2);

    std::cout << "Distance between points: " << distance << std::endl;

    return 0;
}

```


```cpp
// ç‚¹é›†è½¬çº¿
#include <iostream>
#include <vector>
#include <boost/geometry.hpp>
#include <boost/geometry/geometries/point_xy.hpp>
#include <boost/geometry/geometries/linestring.hpp>

namespace bg = boost::geometry;

typedef bg::model::d2::point_xy<double> Point;
typedef bg::model::linestring<Point> LineString;

int main()
{
    // åˆ›å»ºç‚¹é›†
    std::vector<Point> points;
    points.push_back(Point(0, 0));
    points.push_back(Point(1, 1));
    points.push_back(Point(2, 2));
    points.push_back(Point(3, 3));

    // å°†ç‚¹é›†è½¬æ¢ä¸ºçº¿
    LineString line;
    bg::assign_points(line, points);

    // è¾“å‡ºçº¿çš„åæ ‡
    std::cout << "Line coordinates: ";
    for (auto it = boost::begin(line); it != boost::end(line); ++it)
    {
        std::cout << bg::get<0>(*it) << " " << bg::get<1>(*it) << ", ";
    }
    std::cout << std::endl;

    return 0;
}

```


```cpp
// é¢è¦ç´ è½¬çº¿è¦ç´ 
#include <iostream>
#include <vector>
#include <boost/geometry.hpp>
#include <boost/geometry/geometries/polygon.hpp>
#include <boost/geometry/geometries/linestring.hpp>

namespace bg = boost::geometry;

typedef bg::model::polygon<bg::model::d2::point_xy<double>> Polygon;
typedef bg::model::linestring<bg::model::d2::point_xy<double>> LineString;

void polygonToLineString(const Polygon& polygon, LineString& lineString)
{
    const auto& outerRing = bg::exterior_ring(polygon);
    bg::append(lineString, outerRing);

    for (const auto& innerRing : bg::interior_rings(polygon))
    {
        bg::append(lineString, innerRing);
    }
}

int main()
{
    // åˆ›å»ºä¸€ä¸ªå¤šè¾¹å½¢
    Polygon polygon;
    bg::read_wkt("POLYGON((0 0,0 10,10 10,10 0,0 0),(2 2,2 8,8 8,8 2,2 2))", polygon);

    // å°†å¤šè¾¹å½¢è½¬æ¢ä¸ºçº¿
    LineString lineString;
    polygonToLineString(polygon, lineString);

    // è¾“å‡ºçº¿ä¸Šçš„ç‚¹
    std::cout << "Line points: ";
    for (const auto& point : lineString)
    {
        std::cout << "(" << bg::get<0>(point) << " " << bg::get<1>(point) << "), ";
    }
    std::cout << std::endl;

    return 0;
}

```


```cpp
// çº¿è¦ç´ è½¬ç‚¹è¦ç´ 
#include <iostream>
#include <vector>
#include <boost/geometry.hpp>
#include <boost/geometry/geometries/point.hpp>
#include <boost/geometry/geometries/linestring.hpp>

namespace bg = boost::geometry;

typedef bg::model::point<double, 2, bg::cs::cartesian> Point;
typedef bg::model::linestring<Point> LineString;

void lineStringToPoints(const LineString& lineString, std::vector<Point>& points)
{
    for (const auto& point : lineString)
    {
        points.push_back(point);
    }
}

int main()
{
    // åˆ›å»ºä¸€ä¸ªçº¿è¦ç´ 
    LineString lineString;
    lineString.push_back(Point(0, 0));
    lineString.push_back(Point(1, 1));
    lineString.push_back(Point(2, 2));

    // å°†çº¿è¦ç´ è½¬æ¢ä¸ºç‚¹
    std::vector<Point> points;
    lineStringToPoints(lineString, points);

    // è¾“å‡ºç‚¹çš„åæ ‡
    std::cout << "Point coordinates: ";
    for (const auto& point : points)
    {
        std::cout << "(" << bg::get<0>(point) << " " << bg::get<1>(point) << "), ";
    }
    std::cout << std::endl;

    return 0;
}

```

### Boost.PropertyTree

INIé…ç½®æ–‡ä»¶è§£æç¤ºä¾‹ï¼š

```cpp
#include <iostream>
#include <boost/property_tree/ptree.hpp>
#include <boost/property_tree/ini_parser.hpp>

using namespace std;

/*
[Section1]
Username = john
Password = secret

[Section2]
Port = 8080
*/

int main() {
    // åˆ›å»ºä¸€ä¸ªproperty_treeå¯¹è±¡
    boost::property_tree::ptree pt;
    // ä½¿ç”¨ini_parseråº“åŠ è½½INIæ–‡ä»¶
    boost::property_tree::ini_parser::read_ini("./data/data.ini", pt);

    // è¯»å–é…ç½®é¡¹çš„å€¼
    std::string username = pt.get<std::string>("Section1.Username");
    std::string password = pt.get<std::string>("Section1.Password");
    int port = pt.get<int>("Section2.Port");

    // æ‰“å°è¯»å–çš„å€¼
    std::cout << "Username: " << username << std::endl;
    std::cout << "Password: " << password << std::endl;
    std::cout << "Port: " << port << std::endl;

    return 0;
}

```

XMLé…ç½®æ–‡ä»¶è§£æç¤ºä¾‹ï¼š

```cpp
#include <iostream>
#include <boost/property_tree/ptree.hpp>
#include <boost/property_tree/xml_parser.hpp>

/*
<root>
 <title>Sample Book</title>
 <year>2023</year>
 <author>John Doe</author>
</root>
*/

int main() {
    // åˆ›å»ºä¸€ä¸ªproperty_treeå¯¹è±¡
    boost::property_tree::ptree pt;

    try {
        // ä½¿ç”¨xml_parseråº“åŠ è½½XMLæ–‡ä»¶
        boost::property_tree::read_xml("./data/data.xml", pt);

        // è¯»å–XMLèŠ‚ç‚¹çš„å€¼
        std::string title = pt.get<std::string>("root.title");
        int year = pt.get<int>("root.year");
        std::string author = pt.get<std::string>("root.author");

        // æ‰“å°è¯»å–çš„å€¼
        std::cout << "Title: " << title << std::endl;
        std::cout << "Year: " << year << std::endl;
        std::cout << "Author: " << author << std::endl;
    } catch (const boost::property_tree::ptree_error& e) {
        // å¤„ç†è§£æé”™è¯¯
        std::cerr << "XML parsing error: " << e.what() << std::endl;
    }

    return 0;
}

```

JSONé…ç½®æ–‡ä»¶è§£æç¤ºä¾‹ï¼š

```cpp
#include <iostream>
#include <boost/property_tree/ptree.hpp>
#include <boost/property_tree/json_parser.hpp>

/*
{
 "name": "John Doe",
 "age": 30,
 "address": {
 "city": "New York",
 "street": "123 Main St"
 }
}
*/

int main() {
    // åˆ›å»ºä¸€ä¸ªproperty_treeå¯¹è±¡
    boost::property_tree::ptree pt;

    try {
        // ä½¿ç”¨json_parseråº“åŠ è½½JSONæ–‡ä»¶
        boost::property_tree::read_json("./data/data.json", pt);

        // è¯»å–JSONèŠ‚ç‚¹çš„å€¼
        std::string name = pt.get<std::string>("name");
        int age = pt.get<int>("age");
        std::string city = pt.get<std::string>("address.city");
        std::string street = pt.get<std::string>("address.street");

        // æ‰“å°è¯»å–çš„å€¼
        std::cout << "Name: " << name << std::endl;
        std::cout << "Age: " << age << std::endl;
        std::cout << "City: " << city << std::endl;
        std::cout << "Street: " << street << std::endl;
    } catch (const boost::property_tree::ptree_error& e) {
        // å¤„ç†è§£æé”™è¯¯
        std::cerr << "JSON parsing error: " << e.what() << std::endl;
    }

    return 0;
}

```

### Boost.InterProcess

å…±äº«å†…å­˜è¯»å†™ç¤ºä¾‹

```cpp
#include <boost/interprocess/shared_memory_object.hpp>
#include <boost/interprocess/mapped_region.hpp>
#include <iostream>

using namespace boost::interprocess;

int main()
{
    // åˆ›å»ºæˆ–æ‰“å¼€å…±äº«å†…å­˜å¯¹è±¡
    shared_memory_object shm(open_or_create, "my_shared_memory", read_write);

    // è®¾ç½®å…±äº«å†…å­˜å¯¹è±¡çš„å¤§å°
    shm.truncate(1024);

    // æ˜ å°„å…±äº«å†…å­˜åˆ°å½“å‰è¿›ç¨‹çš„åœ°å€ç©ºé—´
    mapped_region region(shm, read_write);

    // è·å–å…±äº«å†…å­˜çš„é¦–åœ°å€
    void* addr = region.get_address();

    // å†™å…¥æ•°æ®åˆ°å…±äº«å†…å­˜
    const char* str = "Hello, Boost.Interprocess!";
    std::strcpy(static_cast<char*>(addr), str);

    // ä»å…±äº«å†…å­˜è¯»å–æ•°æ®
    char buffer[1024];
    std::strcpy(buffer, static_cast<char*>(addr));

    // è¾“å‡ºè¯»å–åˆ°çš„æ•°æ®
    std::cout << "Message from shared memory: " << buffer << std::endl;

    // åˆ é™¤å…±äº«å†…å­˜å¯¹è±¡
    shared_memory_object::remove("my_shared_memory");

    return 0;
}

```

### Boost.Asio

httpæœåŠ¡ç«¯ç¤ºä¾‹ï¼š

```cpp
#include <boost/beast.hpp>
#include <boost/asio.hpp>
#include <iostream>

namespace beast = boost::beast;
namespace http = beast::http;
namespace net = boost::asio;
using tcp = net::ip::tcp;

void handle_request(http::request<http::string_body>& request, http::response<http::string_body>& response) {
    // å¤„ç†è¯·æ±‚å¹¶ç”Ÿæˆå“åº”
    response.version(request.version());
    response.result(http::status::ok);
    response.set(http::field::server, "Boost Beast HTTP Server");
    response.body() = "Hello, World!";
    response.prepare_payload();
}

int main() {
    try {
        // åˆ›å»º IO ä¸Šä¸‹æ–‡å’Œè§£æå™¨
        net::io_context io_context;

        // åˆ›å»ºç›‘å¬ç«¯å£
        tcp::acceptor acceptor(io_context, tcp::endpoint(tcp::v4(), 8881));

        while (true) {
            // æ¥å—è¿æ¥
            tcp::socket socket(io_context);
            acceptor.accept(socket);

            // è¯»å–è¯·æ±‚
            beast::flat_buffer buffer;
            http::request<http::string_body> request;
            http::read(socket, buffer, request);

            // å¤„ç†è¯·æ±‚å¹¶ç”Ÿæˆå“åº”
            http::response<http::string_body> response;
            handle_request(request, response);

            // å‘é€å“åº”
            http::write(socket, response);
        }
    } catch (const std::exception& e) {
        std::cerr << "Error: " << e.what() << std::endl;
        return 1;
    }

    return 0;
}

```

httpå®¢æˆ·ç«¯ç¤ºä¾‹ï¼š

```cpp
#include <boost/beast.hpp>
#include <boost/asio.hpp>
#include <iostream>

namespace beast = boost::beast;
namespace http = beast::http;
namespace net = boost::asio;
using tcp = net::ip::tcp;

int main() {
    try {
        // åˆ›å»º IO ä¸Šä¸‹æ–‡å’Œè§£æå™¨
        net::io_context io_context;
        tcp::resolver resolver(io_context);
        beast::tcp_stream stream(io_context);

        // è§£æä¸»æœºå’Œç«¯å£
        auto const results = resolver.resolve("localhost", "8881");

        // è¿æ¥åˆ°æœåŠ¡å™¨
        stream.connect(results);

        // åˆ›å»º HTTP è¯·æ±‚
        http::request<http::string_body> request(http::verb::get, "/", 11);
        request.set(http::field::host, "localhost");
        request.set(http::field::user_agent, "Boost Beast");

        // å‘é€è¯·æ±‚
        http::write(stream, request);

        // æ¥æ”¶å¹¶æ‰“å°å“åº”
        beast::flat_buffer buffer;
        http::response<http::string_body> response;
        http::read(stream, buffer, response);

        std::cout << "Response code: " << response.result_int() << std::endl;
        std::cout << "Response body: " << response.body() << std::endl;
    } catch (const std::exception& e) {
        std::cerr << "Error: " << e.what() << std::endl;
        return 1;
    }

    return 0;
}

```

ç¼–è¯‘è¿è¡Œï¼š

```
g++ -o server server.cpp -lboost_system -lboost_thread -lpthread
g++ -o client client.cpp -lboost_system -lboost_thread -lpthread

```

TCPæœåŠ¡ç«¯ç¤ºä¾‹ï¼š

```cpp
#include <iostream>
#include <boost/asio.hpp>

using boost::asio::ip::tcp;

int main()
{
    try
    {
        boost::asio::io_context io_context;

        // åˆ›å»ºä¸€ä¸ª TCP acceptorï¼Œç›‘å¬æŒ‡å®šç«¯å£
        tcp::acceptor acceptor(io_context, tcp::endpoint(tcp::v4(), 8081));

        // ç­‰å¾…å¹¶æ¥å—è¿æ¥
        tcp::socket socket(io_context);
        acceptor.accept(socket);

        // æ¥æ”¶å®¢æˆ·ç«¯çš„æ¶ˆæ¯
        char response[1024];
        size_t bytesRead = socket.read_some(boost::asio::buffer(response));

        std::cout << "Response from client: ";
        std::cout.write(response, bytesRead);

        // å¤„ç†è¿æ¥è¯·æ±‚
        std::string message = "Hello, Boost.Asio!";
        boost::system::error_code ignored_error;
        boost::asio::write(socket, boost::asio::buffer(message), ignored_error);
    }
    catch (std::exception& e)
    {
        std::cerr << "Exception: " << e.what() << std::endl;
    }

    return 0;
}

```

ç¼–è¯‘è¿è¡Œï¼š

```
g++ -o server server.cpp -lboost_system -lpthread
./server

```

TCPå®¢æˆ·ç«¯ç¤ºä¾‹ï¼š

```cpp
#include <iostream>
#include <boost/asio.hpp>

using boost::asio::ip::tcp;

int main() {
  try {
    // åˆ›å»ºIOä¸Šä¸‹æ–‡å¯¹è±¡
    boost::asio::io_context io_context;

    // åˆ›å»ºsocketå¯¹è±¡
    tcp::socket socket(io_context);

    // è§£ææœåŠ¡å™¨åœ°å€å’Œç«¯å£
    tcp::resolver resolver(io_context);
    tcp::resolver::results_type endpoints = resolver.resolve("127.0.0.1", "8081");

    // è¿æ¥åˆ°æœåŠ¡å™¨
    boost::asio::connect(socket, endpoints);

    // å‘é€æ•°æ®ç»™æœåŠ¡å™¨
    std::string request = "Hello, server!";
    boost::asio::write(socket, boost::asio::buffer(request));

    // æ¥æ”¶æœåŠ¡å™¨çš„å“åº”
    char response[1024];
    size_t bytesRead = socket.read_some(boost::asio::buffer(response));

    // æ˜¾ç¤ºæœåŠ¡å™¨çš„å“åº”
    std::cout << "Response from server: ";
    std::cout.write(response, bytesRead);
    std::cout << std::endl;

  } catch (std::exception& e) {
    std::cerr << "Exception: " << e.what() << std::endl;
  }

  return 0;
}

```

ç¼–è¯‘è¿è¡Œï¼š

```
g++ -o client client.cpp -lboost_system -lpthread
./client

```

UDPæœåŠ¡ç«¯ç¤ºä¾‹ï¼š

```cpp
#include <iostream>
#include <boost/asio.hpp>

using boost::asio::ip::udp;

int main()
{
    boost::asio::io_context io_context;

    // åˆ›å»ºUDPç«¯ç‚¹å¹¶ç»‘å®šåˆ°ç‰¹å®šç«¯å£
    udp::socket socket(io_context, udp::endpoint(udp::v4(), 8888));

    // æ¥æ”¶ç¼“å†²åŒº
    char recv_buffer[1024];

    while (true) {
        udp::endpoint remote_endpoint;

        // æ¥æ”¶æ•°æ®
        size_t bytes_received = socket.receive_from(boost::asio::buffer(recv_buffer), remote_endpoint);

        // æ‰“å°æ¥æ”¶åˆ°çš„æ•°æ®
        std::cout.write(recv_buffer, bytes_received);
        std::cout << std::endl;

        // å‘é€å›å¤
        std::string message = "Hello from server!";
        socket.send_to(boost::asio::buffer(message), remote_endpoint);
    }

    return 0;
}

```

UDPå®¢æˆ·ç«¯ç¤ºä¾‹ï¼š

```cpp
#include <iostream>
#include <boost/asio.hpp>

using boost::asio::ip::udp;

int main()
{
    boost::asio::io_context io_context;

    // åˆ›å»ºUDPç«¯ç‚¹å¹¶ç»‘å®šåˆ°ä»»æ„ç«¯å£
    udp::socket socket(io_context, udp::endpoint(udp::v4(), 0));

    // è¿œç¨‹æœåŠ¡å™¨ç«¯ç‚¹
    udp::endpoint remote_endpoint(boost::asio::ip::address::from_string("127.0.0.1"), 8888);

    // å‘é€æ•°æ®
    std::string message = "Hello from client!";
    socket.send_to(boost::asio::buffer(message), remote_endpoint);

    // æ¥æ”¶ç¼“å†²åŒº
    char recv_buffer[1024];

    // æ¥æ”¶å›å¤
    udp::endpoint sender_endpoint;
    size_t bytes_received = socket.receive_from(boost::asio::buffer(recv_buffer), sender_endpoint);

    // æ‰“å°å›å¤æ•°æ®
    std::cout.write(recv_buffer, bytes_received);
    std::cout << std::endl;

    return 0;
}

```

websocketæœåŠ¡ç«¯ç¤ºä¾‹ï¼š

```cpp
#include <iostream>
#include <string>
#include <boost/asio.hpp>
#include <boost/beast.hpp>
#include <thread>

namespace asio = boost::asio;
namespace beast = boost::beast;
using tcp = asio::ip::tcp;

void SendMessages(beast::websocket::stream<tcp::socket>& ws) {
    try {
        // Send a message every 1 seconds
        while (true) {
            std::this_thread::sleep_for(std::chrono::seconds(1));
            ws.write(asio::buffer("Server: Sending a message from the server!"));
        }
    } catch (const std::exception &e) {
        std::cerr << "Exception in SendMessages: " << e.what() << std::endl;
    }
}

int main() {
    try {
        asio::io_context io_context;

        // Create and bind the acceptor
        tcp::acceptor acceptor(io_context, {tcp::v4(), 8881});

        while (true) {
            // Accept connection
            tcp::socket socket(io_context);
            acceptor.accept(socket);

            // WebSocket upgrade
            beast::websocket::stream<tcp::socket> ws(std::move(socket));
            ws.accept();

            // Start a thread to send messages to the client
            std::thread senderThread(SendMessages, std::ref(ws));

            // Read WebSocket message
            beast::flat_buffer buffer;
            ws.read(buffer);

            // Print received message
            std::cout << "Received: " << beast::buffers_to_string(buffer.data()) << std::endl;

            // Echo the message back to the client
            ws.text(ws.got_text());
            ws.write(buffer.data());

            // Join the sender thread
            senderThread.join();
        }
    } catch (const std::exception &e) {
        std::cerr << "Exception: " << e.what() << std::endl;
    }

    return 0;
}

```

websocketå®¢æˆ·ç«¯ç¤ºä¾‹ï¼š

```cpp
#include <iostream>
#include <string>
#include <boost/asio.hpp>
#include <boost/beast.hpp>

namespace asio = boost::asio;
namespace beast = boost::beast;
using tcp = asio::ip::tcp;

int main() {
    try {
        asio::io_context io_context;

        // Resolve the host name
        tcp::resolver resolver(io_context);
        auto const results = resolver.resolve("localhost", "8881");

        // Connect to the server
        tcp::socket socket(io_context);
        asio::connect(socket, results);

        // WebSocket upgrade
        beast::websocket::stream<tcp::socket> ws(std::move(socket));
        ws.handshake("localhost", "/");

        // Receive and print the initial message from the server
        beast::flat_buffer buffer;
        ws.read(buffer);
        std::cout << "Received: " << beast::buffers_to_string(buffer.data()) << std::endl;

        // Start a thread to continuously receive messages from the server
        std::thread receiverThread([&ws] {
            try {
                while (true) {
                    beast::flat_buffer buffer;
                    ws.read(buffer);
                    std::cout << "Received: " << beast::buffers_to_string(buffer.data()) << std::endl;
                }
            } catch (const std::exception &e) {
                std::cerr << "Exception in receiverThread: " << e.what() << std::endl;
            }
        });

        // Send a WebSocket message
        ws.text(true);
        ws.write(asio::buffer("Client: Hello, Server!"));

        // Join the receiver thread
        receiverThread.join();

        // Close the WebSocket connection
        ws.close(beast::websocket::close_code::normal);
    } catch (const std::exception &e) {
        std::cerr << "Exception: " << e.what() << std::endl;
    }

    return 0;
}

```

æœåŠ¡ç«¯ç¤ºä¾‹ï¼š

```cpp
#include <iostream>
#include <string>
#include <boost/beast/core.hpp>
#include <boost/beast/websocket.hpp>
#include <boost/asio/ip/tcp.hpp>
#include <boost/asio/io_context.hpp>

namespace beast = boost::beast;
namespace websocket = beast::websocket;
using tcp = boost::asio::ip::tcp;

void runWebSocketServer(unsigned short port) {
    try {
        boost::asio::io_context io_context;

        tcp::acceptor acceptor(io_context, tcp::endpoint(tcp::v4(), port));
        tcp::socket socket(io_context);
        acceptor.accept(socket);

        websocket::stream<tcp::socket> ws(std::move(socket));
        ws.accept();

        while (true) {
            beast::flat_buffer buffer;
            ws.read(buffer);

            std::string message(beast::buffers_to_string(buffer.data()));
            std::cout << "Received message: " << message << " port: " << port << std::endl;

            ws.text(ws.got_text());
            ws.write(boost::asio::buffer("Response: " + message));
        }
    } catch (const std::exception& e) {
        std::cerr << "Error: " << e.what() << std::endl;
    }
}

int main() {
    std::cout << "WebSocket server is running..." << std::endl;

    unsigned short port = 9002;
    runWebSocketServer(port);

    // å¯åœ¨å¤šçº¿ç¨‹ä¸­å¼€å¯å¤šä¸ªç«¯å£
    // unsigned short port2 = 9003;
    // runWebSocketServer(port2);

    return 0;
}

```

å®¢æˆ·ç«¯ç¤ºä¾‹ï¼š

```cpp
#include <iostream>
#include <chrono>
#include <thread>
#include <boost/beast/core.hpp>
#include <boost/beast/websocket.hpp>
#include <boost/asio/ip/tcp.hpp>
#include <boost/asio/connect.hpp>
#include <boost/asio/io_context.hpp>

namespace beast = boost::beast;
namespace websocket = beast::websocket;
using tcp = boost::asio::ip::tcp;

void runWebSocketClient(const std::string& serverAddress, unsigned short port) {
    try {
        boost::asio::io_context io_context;
        tcp::resolver resolver(io_context);
        websocket::stream<tcp::socket> ws(io_context);

        auto const results = resolver.resolve(serverAddress, std::to_string(port));
        boost::asio::connect(ws.next_layer(), results.begin(), results.end());
        ws.handshake(serverAddress, "/");

        while (true) {
            std::string message = "Hello, WebSocket!";
            ws.write(boost::asio::buffer(message));

            beast::flat_buffer buffer;
            ws.read(buffer);
            std::cout << "Server response: " << beast::buffers_to_string(buffer.data()) << " port: " << port << std::endl;

            std::this_thread::sleep_for(std::chrono::seconds(1));
        }

        // ws.close(websocket::close_code::normal);
    } catch (const std::exception& e) {
        std::cerr << "Error: " << e.what() << std::endl;
    }
}

int main() {
    std::cout << "WebSocket client example" << std::endl;

    std::string serverAddress = "localhost";
    unsigned short port = 9002;
    runWebSocketClient(serverAddress, port);

    // å¯åœ¨å¤šçº¿ç¨‹ä¸­å¼€å¯å¤šä¸ªç«¯å£
    // unsigned short port2 = 9003;
    // runWebSocketClient(serverAddress, port2);

    return 0;
}

```

ç¼–è¯‘ï¼š

```
g++ server.cpp -o server -lboost_system -lboost_thread -lpthread
g++ client.cpp -o client -lboost_system -lboost_thread -lpthread

```

![åœ¨è¿™é‡Œæ’å…¥å›¾ç‰‡æè¿°](https://img-blog.csdnimg.cn/6cbcd6c17cec4dba9bb3c0f895f02fa2.png)


ä»¥ä¸Šã€‚





