







> 
> ğŸ˜*â˜…,Â°*:.â˜†(ï¿£â–½ï¿£)/$:*.Â°â˜…* ğŸ˜  
>  è¿™ç¯‡æ–‡ç« ä¸»è¦ä»‹ç»äº‹ä»¶é©±åŠ¨åº“libeventé…ç½®ä½¿ç”¨ã€‚  
>  **æ— ä¸“ç²¾åˆ™ä¸èƒ½æˆï¼Œæ— æ¶‰çŒåˆ™ä¸èƒ½é€šã€‚â€”â€”æ¢å¯è¶…**  
>  æ¬¢è¿æ¥åˆ°æˆ‘çš„åšå®¢ï¼Œä¸€èµ·å­¦ä¹ ï¼Œå…±åŒè¿›æ­¥ã€‚  
>  å–œæ¬¢çš„æœ‹å‹å¯ä»¥å…³æ³¨ä¸€ä¸‹ï¼Œä¸‹æ¬¡æ›´æ–°ä¸è¿·è·¯ğŸ¥
> 
> 
> 




#### æ–‡ç« ç›®å½•


* + [:smirk:1. é¡¹ç›®ä»‹ç»](#smirk1__7)
	+ [:blush:2. ç¯å¢ƒé…ç½®](#blush2__27)
	+ [:satisfied:3. ä½¿ç”¨è¯´æ˜](#satisfied3__45)




### ğŸ˜1. é¡¹ç›®ä»‹ç»


é¡¹ç›®Githubåœ°å€ï¼š`https://github.com/libevent/libevent`


å®˜ç½‘ï¼š`https://libevent.org/`


libeventæ˜¯ä¸€ä¸ªå¼€æºçš„äº‹ä»¶é©±åŠ¨åº“ï¼Œç”¨äºå¼€å‘é«˜æ€§èƒ½ã€å¯æ‰©å±•çš„ç½‘ç»œåº”ç”¨ç¨‹åºã€‚å®ƒæä¾›äº†è·¨å¹³å°çš„æŠ½è±¡æ¥å£ï¼Œä½¿å¼€å‘äººå‘˜èƒ½å¤Ÿä½¿ç”¨äº‹ä»¶å›è°ƒæ¥ç®¡ç†ç½‘ç»œè¿æ¥ã€å®šæ—¶å™¨å’Œä¿¡å·ç­‰äº‹ä»¶ã€‚


ä»¥ä¸‹æ˜¯libeventåº“çš„ä¸€äº›ä¸»è¦ç‰¹ç‚¹å’ŒåŠŸèƒ½ï¼š



> 
> 1.äº‹ä»¶é©±åŠ¨ï¼šlibeventä½¿ç”¨äº‹ä»¶é©±åŠ¨çš„æ–¹å¼å¤„ç†ç½‘ç»œå’ŒI/Oæ“ä½œã€‚å®ƒåŸºäºå›è°ƒæœºåˆ¶ï¼Œå¯ä»¥å¤„ç†å„ç§äº‹ä»¶ï¼ŒåŒ…æ‹¬ç½‘ç»œè¿æ¥ã€è¯»å†™æ“ä½œã€å®šæ—¶å™¨ç­‰ã€‚
> 
> 
> 



> 
> 2.è·¨å¹³å°æ”¯æŒï¼šlibeventå¯ä»¥åœ¨å¤šä¸ªå¹³å°ä¸Šè¿è¡Œï¼ŒåŒ…æ‹¬Linuxã€Unixã€Windowsç­‰ã€‚å®ƒå°è£…äº†ä¸åŒæ“ä½œç³»ç»Ÿçš„åº•å±‚APIï¼Œä½¿å¼€å‘äººå‘˜èƒ½å¤Ÿåœ¨ä¸åŒå¹³å°ä¸Šå®ç°ç›¸åŒçš„åŠŸèƒ½ã€‚
> 
> 
> 



> 
> 3.é«˜æ€§èƒ½ï¼šlibeventè¢«è®¾è®¡æˆé«˜æ•ˆçš„äº‹ä»¶é€šçŸ¥å¼•æ“ï¼Œå®ƒä½¿ç”¨äº†é«˜æ•ˆçš„I/Oå¤šè·¯å¤ç”¨æŠ€æœ¯ï¼ˆå¦‚epollã€kqueueç­‰ï¼‰ï¼Œèƒ½å¤ŸåŒæ—¶å¤„ç†å¤§é‡çš„å¹¶å‘è¿æ¥å’Œäº‹ä»¶ã€‚
> 
> 
> 



> 
> 4.å¯æ‰©å±•æ€§ï¼šlibeventæä¾›äº†å¯æ‰©å±•çš„æ¥å£å’Œæœºåˆ¶ï¼Œå¼€å‘äººå‘˜å¯ä»¥è‡ªå®šä¹‰äº‹ä»¶çš„å¤„ç†æ–¹å¼ï¼Œå¹¶æ·»åŠ è‡ªå®šä¹‰çš„äº‹ä»¶ç±»å‹ã€‚å®ƒè¿˜æ”¯æŒå¤šçº¿ç¨‹å’Œå¤šè¿›ç¨‹ç¼–ç¨‹æ¨¡å‹ï¼Œæ–¹ä¾¿å®ç°å¹¶å‘å¤„ç†ã€‚
> 
> 
> 



> 
> 5.æ”¯æŒå¤šç§åè®®ï¼šlibeventæ”¯æŒå¤šç§ç½‘ç»œåè®®ï¼ŒåŒ…æ‹¬TCPã€UDPã€SSLç­‰ã€‚å®ƒæä¾›äº†ç›¸åº”çš„APIå’ŒåŠŸèƒ½ï¼Œä»¥ä¾¿å¼€å‘äººå‘˜è½»æ¾åœ°æ„å»ºå„ç§ç½‘ç»œåº”ç”¨ç¨‹åºã€‚
> 
> 
> 


libevent æ˜¯ä¸€ä¸ªåŠŸèƒ½å¼ºå¤§çš„äº‹ä»¶é©±åŠ¨ç½‘ç»œåº“ï¼Œå¹¿æ³›åº”ç”¨äºæ„å»ºé«˜æ€§èƒ½çš„æœåŠ¡å™¨ç¨‹åºã€ä»£ç†ã€è´Ÿè½½å‡è¡¡å™¨ç­‰ç½‘ç»œåº”ç”¨ã€‚å®ƒæä¾›äº†ç®€æ´çš„æ¥å£å’Œä¸°å¯Œçš„åŠŸèƒ½ï¼Œä½¿å¼€å‘äººå‘˜èƒ½å¤Ÿè½»æ¾åœ°ç¼–å†™é«˜æ•ˆã€å¯æ‰©å±•çš„ç½‘ç»œåº”ç”¨ç¨‹åºã€‚


### ğŸ˜Š2. ç¯å¢ƒé…ç½®


ä¸‹é¢è¿›è¡Œç¯å¢ƒé…ç½®ï¼š



```
# aptå®‰è£…
sudo apt install libevent-dev
# æŸ¥çœ‹ç‰ˆæœ¬ï¼ˆubuntué»˜è®¤2.1.8-stableï¼‰
pkg-config --modversion libevent

```


```
# æºç å®‰è£…
tar -zxvf libevent-2.0.22-stable.tar.gz
cd libevent-2.0.22-stable/
./configure
make
sudo make install

```

### ğŸ˜†3. ä½¿ç”¨è¯´æ˜


å®šæ—¶å™¨äº‹ä»¶ç¤ºä¾‹ï¼š



```
#include <iostream>
#include <event2/event.h>

void timerCallback(evutil_socket_t fd, short events, void\* arg) {
    std::cout << "Timer expired" << std::endl;

    // åœæ­¢äº‹ä»¶å¾ªç¯
    event_base\* base = static\_cast<event\_base\*>(arg);
    event\_base\_loopbreak(base);
}

int main() {
    // åˆ›å»ºäº‹ä»¶åŸºç¡€
    event_base\* base = event\_base\_new();
    if (!base) {
        std::cerr << "Failed to create event base" << std::endl;
        return 1;
    }
    std::cout << "start event..." << std::endl;

    // åˆ›å»ºå®šæ—¶å™¨äº‹ä»¶
    timeval tv = {2, 0};  // 2 ç§’
    event\* timerEvent = evtimer\_new(base, timerCallback, base);
    if (!timerEvent) {
        std::cerr << "Failed to create timer event" << std::endl;
        return 1;
    }

    // æ·»åŠ å®šæ—¶å™¨äº‹ä»¶
    if (evtimer\_add(timerEvent, &tv) < 0) {
        std::cerr << "Failed to add timer event" << std::endl;
        return 1;
    }

    // å¯åŠ¨äº‹ä»¶å¾ªç¯
    event\_base\_dispatch(base);

    // æ¸…ç†èµ„æº
    event\_free(timerEvent);
    event\_base\_free(base);

    return 0;
}

```

ç¼–è¯‘è¿è¡Œï¼š



```
g++ -o main main.cpp -levent
./main

```

åŸºäºlibeventçš„çº¿ç¨‹æ± ç¤ºä¾‹ï¼š



```
#include <event2/event.h>
#include <event2/thread.h>
#include <iostream>
#include <vector>
#include <queue>
#include <mutex>
#include <condition\_variable>
#include <functional>
#include <thread>

// ä»»åŠ¡ç»“æ„ä½“
struct Task {
    std::function<void()> function;

    Task(const std::function<void()>& f) : function(f) {}
};

// çº¿ç¨‹æ± ç±»
class ThreadPool {
public:
    ThreadPool(int numThreads) : stop(false) {
        // åˆå§‹åŒ–libeventçº¿ç¨‹æ”¯æŒ
        evthread\_use\_pthreads();

        for (int i = 0; i < numThreads; ++i) {
            threads.emplace\_back([this] {
                event_base\* base = event\_base\_new();
                if (!base) {
                    std::cerr << "Failed to create event base." << std::endl;
                    return;
                }

                // åˆ›å»ºäº‹ä»¶æ¥è§¦å‘ä»»åŠ¡æ‰§è¡Œ
                event\* ev = event\_new(base, -1, EV_PERSIST, [](evutil_socket_t fd, short events, void\* arg) {
                    ThreadPool\* threadPool = static\_cast<ThreadPool\*>(arg);
                    threadPool->executeTask();
                }, this);

                timeval delay = { 0, 1000 }; // æ¯éš”1æ¯«ç§’è§¦å‘ä¸€æ¬¡äº‹ä»¶
                event\_add(ev, &delay);

                // æ‰§è¡Œäº‹ä»¶å¾ªç¯
                event\_base\_dispatch(base);

                event\_free(ev);
                event\_base\_free(base);
            });
        }
    }

    ~ThreadPool() {
        {
            std::unique_lock<std::mutex> lock(taskMutex);
            stop = true;
        }

        taskCondition.notify\_all();

        for (auto& thread : threads) {
            thread.join();
        }
    }

    template<class F>
    void enqueue(F&& f) {
        {
            std::unique_lock<std::mutex> lock(taskMutex);
            tasks.emplace(new Task(std::forward<F>(f)));
        }

        taskCondition.notify\_one();
    }

private:
    std::vector<std::thread> threads;
    std::queue<Task\*> tasks;

    std::mutex taskMutex;
    std::condition_variable taskCondition;

    bool stop;

    void executeTask() {
        Task\* task = nullptr;

        {
            std::unique_lock<std::mutex> lock(taskMutex);

            if (tasks.empty()) {
                return;
            }

            task = tasks.front();
            tasks.pop();
        }

        task->function();

        delete task;
    }
};

// ç¤ºä¾‹ä½¿ç”¨
void taskFunction(int id) {
    std::cout << "Task " << id << " is being executed." << std::endl;
}

int main() {
    const int numThreads = 4;
    ThreadPool threadPool(numThreads);
    std::cout << "Create " << numThreads << " pools..." << std::endl;

    // æäº¤ä»»åŠ¡åˆ°çº¿ç¨‹æ± 
    for (int i = 0; i < 10; ++i) {
        threadPool.enqueue([i] {
            taskFunction(i);
        });
    }

    // ç­‰å¾…æ‰€æœ‰ä»»åŠ¡å®Œæˆ
    std::this_thread::sleep\_for(std::chrono::seconds(3));
    std::cout << "Task end!!!" << std::endl;

    return 0;
}


```

ç¼–è¯‘è¿è¡Œï¼š



```
g++ -o main main.cpp -levent -lpthread -levent\_pthreads

```

TCPæœåŠ¡ç«¯å’Œå®¢æˆ·ç«¯ç¤ºä¾‹ï¼š



```
// server.cpp
#include <iostream>
#include <cstring>
#include <event2/event.h>
#include <event2/listener.h>
#include <event2/bufferevent.h>

void readCallback(bufferevent\* bev, void\* arg) {
    char data[1024];
    int n;
    while ((n = bufferevent\_read(bev, data, sizeof(data))) > 0) {
        std::cout << "Received message: " << std::string(data, n);
        // åœ¨è¿™é‡Œå¯ä»¥å¤„ç†æ¥æ”¶åˆ°çš„æ¶ˆæ¯
    }
}

void writeCallback(bufferevent\* bev, void\* arg) {
    // åœ¨è¿™é‡Œå¯ä»¥å¤„ç†å‘é€å®Œæˆçš„é€»è¾‘
}

void eventCallback(bufferevent\* bev, short events, void\* arg) {
    if (events & BEV_EVENT_ERROR) {
        std::cerr << "Error occurred" << std::endl;
    }
    if (events & (BEV_EVENT_EOF | BEV_EVENT_ERROR)) {
        std::cout << "Connection closed" << std::endl;
        bufferevent\_free(bev);
    }
}

void acceptCallback(evconnlistener\* listener, evutil_socket_t fd, sockaddr\* address, int socklen, void\* arg) {
    std::cout << "Accepted connection" << std::endl;

    // åˆ›å»º bufferevent å¯¹è±¡
    event_base\* base = evconnlistener\_get\_base(listener);
    bufferevent\* bev = bufferevent\_socket\_new(base, fd, BEV_OPT_CLOSE_ON_FREE);
    if (!bev) {
        std::cerr << "Failed to create bufferevent" << std::endl;
        evutil\_closesocket(fd);
        return;
    }

    // è®¾ç½®å›è°ƒå‡½æ•°
    bufferevent\_setcb(bev, readCallback, writeCallback, eventCallback, nullptr);

    // å¯ç”¨è¯»å†™äº‹ä»¶
    bufferevent\_enable(bev, EV_READ | EV_WRITE);
}

int main() {
    // åˆ›å»ºäº‹ä»¶åŸºç¡€
    event_base\* base = event\_base\_new();
    if (!base) {
        std::cerr << "Failed to create event base" << std::endl;
        return 1;
    }

    // åˆ›å»ºç›‘å¬å™¨
    sockaddr_in sin;
    std::memset(&sin, 0, sizeof(sin));
    sin.sin_family = AF_INET;
    sin.sin_addr.s_addr = htonl(INADDR_ANY);
    sin.sin_port = htons(12345);

    evconnlistener\* listener = evconnlistener\_new\_bind(
        base,
        acceptCallback,
        nullptr,
        LEV_OPT_REUSEABLE | LEV_OPT_CLOSE_ON_FREE,
        -1,
        (struct sockaddr\*)&sin,
        sizeof(sin)
    );
    if (!listener) {
        std::cerr << "Failed to create listener" << std::endl;
        return 1;
    }

    std::cout << "Server is running..." << std::endl;

    // å¯åŠ¨äº‹ä»¶å¾ªç¯
    event\_base\_dispatch(base);

    // æ¸…ç†èµ„æº
    evconnlistener\_free(listener);
    event\_base\_free(base);

    return 0;
}

```


```
// client.cpp
#include <iostream>
#include <cstring>
#include <arpa/inet.h>
#include <event2/event.h>
#include <event2/bufferevent.h>

void readCallback(bufferevent\* bev, void\* arg) {
    char data[1024];
    int n;
    while ((n = bufferevent\_read(bev, data, sizeof(data))) > 0) {
        std::cout << "Received message: " << std::string(data, n);
        // åœ¨è¿™é‡Œå¯ä»¥å¤„ç†æ¥æ”¶åˆ°çš„æ¶ˆæ¯
    }
}

void writeCallback(bufferevent\* bev, void\* arg) {
    // åœ¨è¿™é‡Œå¯ä»¥å¤„ç†å‘é€å®Œæˆçš„é€»è¾‘
}

void eventCallback(bufferevent\* bev, short events, void\* arg) {
    if (events & BEV_EVENT_CONNECTED) {
        std::cout << "Connected to server" << std::endl;
        // åœ¨è¿™é‡Œå¯ä»¥å¤„ç†è¿æ¥æˆåŠŸçš„é€»è¾‘
    }
    else if (events & BEV_EVENT_ERROR) {
        std::cerr << "Error occurred" << std::endl;
    }
    else if (events & (BEV_EVENT_EOF | BEV_EVENT_ERROR)) {
        std::cout << "Connection closed" << std::endl;
        bufferevent\_free(bev);
    }
}

int main() {
    // åˆ›å»ºäº‹ä»¶åŸºç¡€
    event_base\* base = event\_base\_new();
    if (!base) {
        std::cerr << "Failed to create event base" << std::endl;
        return 1;
    }

    // åˆ›å»º bufferevent å¯¹è±¡
    bufferevent\* bev = bufferevent\_socket\_new(base, -1, BEV_OPT_CLOSE_ON_FREE);
    if (!bev) {
        std::cerr << "Failed to create bufferevent" << std::endl;
        event\_base\_free(base);
        return 1;
    }

    // è®¾ç½®å›è°ƒå‡½æ•°
    bufferevent\_setcb(bev, readCallback, writeCallback, eventCallback, nullptr);

    // è¿æ¥åˆ°æœåŠ¡å™¨
    sockaddr_in sin;
    std::memset(&sin, 0, sizeof(sin));
    sin.sin_family = AF_INET;
    sin.sin_addr.s_addr = inet\_addr("127.0.0.1");
    sin.sin_port = htons(12345);

    if (bufferevent\_socket\_connect(bev, (struct sockaddr\*)&sin, sizeof(sin)) < 0) {
        std::cerr << "Failed to connect to server" << std::endl;
        bufferevent\_free(bev);
        event\_base\_free(base);
        return 1;
    }

    // å¯åŠ¨äº‹ä»¶å¾ªç¯
    event\_base\_dispatch(base);

    // æ¸…ç†èµ„æº
    bufferevent\_free(bev);
    event\_base\_free(base);

    return 0;
}

```

![åœ¨è¿™é‡Œæ’å…¥å›¾ç‰‡æè¿°](https://img-blog.csdnimg.cn/6cbcd6c17cec4dba9bb3c0f895f02fa2.png)


ä»¥ä¸Šã€‚





