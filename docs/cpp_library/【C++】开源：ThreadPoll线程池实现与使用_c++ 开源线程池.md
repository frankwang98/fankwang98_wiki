







> 
> ğŸ˜*â˜…,Â°*:.â˜†(ï¿£â–½ï¿£)/$:*.Â°â˜…* ğŸ˜  
>  è¿™ç¯‡æ–‡ç« ä¸»è¦ä»‹ç»ThreadPollçº¿ç¨‹æ± å®ç°ã€‚  
>  **å­¦å…¶æ‰€ç”¨ï¼Œç”¨å…¶æ‰€å­¦ã€‚â€”â€”æ¢å¯è¶…**  
>  æ¬¢è¿æ¥åˆ°æˆ‘çš„åšå®¢ï¼Œä¸€èµ·å­¦ä¹ ï¼Œå…±åŒè¿›æ­¥ã€‚  
>  å–œæ¬¢çš„æœ‹å‹å¯ä»¥å…³æ³¨ä¸€ä¸‹ï¼Œä¸‹æ¬¡æ›´æ–°ä¸è¿·è·¯ğŸ¥
> 
> 
> 




#### æ–‡ç« ç›®å½•


* + [:smirk:1. çº¿ç¨‹æ± ä»‹ç»](#smirk1__7)
	+ [:blush:2. çº¿ç¨‹æ± å®ç°1-å•å¤´æ–‡ä»¶](#blush2_1_29)
	+ [:satisfied:3. çº¿ç¨‹æ± å®ç°2-è¾ƒå¤æ‚](#satisfied3_2_192)




### ğŸ˜1. çº¿ç¨‹æ± ä»‹ç»


çº¿ç¨‹æ± æ˜¯ä¸€ç§çº¿ç¨‹ç®¡ç†çš„æŠ½è±¡æ¦‚å¿µï¼Œå®ƒä¸»è¦ç”¨äº**ä¼˜åŒ–å¤šçº¿ç¨‹åº”ç”¨ç¨‹åºçš„æ€§èƒ½å’Œèµ„æºåˆ©ç”¨**ã€‚åœ¨å¤šçº¿ç¨‹ç¼–ç¨‹ä¸­ï¼Œåˆ›å»ºå’Œé”€æ¯çº¿ç¨‹æ˜¯ä¸€ä¸ªå¼€é”€è¾ƒå¤§çš„æ“ä½œã€‚çº¿ç¨‹æ± é€šè¿‡é¢„å…ˆåˆ›å»ºä¸€ç»„çº¿ç¨‹ï¼Œå¹¶å°†ä»»åŠ¡æäº¤ç»™è¿™äº›çº¿ç¨‹æ¥æ‰§è¡Œï¼Œä»è€Œé¿å…äº†é‡å¤åˆ›å»ºå’Œé”€æ¯çº¿ç¨‹çš„å¼€é”€ã€‚


çº¿ç¨‹æ± é€šå¸¸ç”±ä»¥ä¸‹å‡ ä¸ªç»„ä»¶ç»„æˆï¼š



> 
> 1.ä»»åŠ¡é˜Ÿåˆ—ï¼ˆTask Queueï¼‰ï¼šç”¨äºå­˜å‚¨å¾…æ‰§è¡Œçš„ä»»åŠ¡ã€‚å½“ä»»åŠ¡æäº¤åˆ°çº¿ç¨‹æ± æ—¶ï¼Œå®ƒä»¬è¢«æ”¾ç½®åœ¨ä»»åŠ¡é˜Ÿåˆ—ä¸­ç­‰å¾…æ‰§è¡Œã€‚
> 
> 
> 2.çº¿ç¨‹æ± ç®¡ç†å™¨ï¼ˆThread Pool Managerï¼‰ï¼šè´Ÿè´£åˆ›å»ºã€ç®¡ç†å’Œè°ƒåº¦çº¿ç¨‹æ± ä¸­çš„çº¿ç¨‹ã€‚å®ƒæ§åˆ¶ç€çº¿ç¨‹çš„æ•°é‡ï¼Œå¯ä»¥åŠ¨æ€åœ°å¢åŠ æˆ–å‡å°‘çº¿ç¨‹çš„æ•°é‡ï¼Œä»¥é€‚åº”ä¸åŒçš„å·¥ä½œè´Ÿè½½ã€‚
> 
> 
> 3.å·¥ä½œçº¿ç¨‹ï¼ˆWorker Threadsï¼‰ï¼šçº¿ç¨‹æ± ä¸­çš„å®é™…æ‰§è¡Œå•å…ƒã€‚å®ƒä»¬ä¸æ–­åœ°ä»ä»»åŠ¡é˜Ÿåˆ—ä¸­è·å–ä»»åŠ¡å¹¶æ‰§è¡Œã€‚
> 
> 
> 4.ä»»åŠ¡æ¥å£ï¼ˆTask Interfaceï¼‰ï¼šå®šä¹‰äº†è¦æ‰§è¡Œçš„ä»»åŠ¡çš„æ¥å£ã€‚é€šå¸¸ï¼Œä»»åŠ¡æ˜¯ä»¥å‡½æ•°æˆ–å¯è¿è¡Œå¯¹è±¡çš„å½¢å¼è¡¨ç¤ºã€‚
> 
> 
> 


ä½¿ç”¨çº¿ç¨‹æ± çš„å¥½å¤„åŒ…æ‹¬ï¼š



> 
> æé«˜æ€§èƒ½ï¼šçº¿ç¨‹æ± å¯ä»¥å‡å°‘çº¿ç¨‹çš„åˆ›å»ºå’Œé”€æ¯æ¬¡æ•°ï¼Œé¿å…äº†é¢‘ç¹çš„ä¸Šä¸‹æ–‡åˆ‡æ¢ï¼Œæé«˜äº†å¤šçº¿ç¨‹ç¨‹åºçš„æ€§èƒ½å’Œå“åº”é€Ÿåº¦ã€‚
> 
> 
> èµ„æºç®¡ç†ï¼šçº¿ç¨‹æ± å¯ä»¥é™åˆ¶å¹¶å‘çº¿ç¨‹çš„æ•°é‡ï¼Œé¿å…èµ„æºè¿‡åº¦å ç”¨ï¼Œä»è€Œæ›´å¥½åœ°ç®¡ç†ç³»ç»Ÿèµ„æºã€‚
> 
> 
> æé«˜å¯æ‰©å±•æ€§ï¼šé€šè¿‡è°ƒæ•´çº¿ç¨‹æ± çš„å¤§å°ï¼Œå¯ä»¥é€‚åº”ä¸åŒçš„å¹¶å‘éœ€æ±‚ï¼Œæé«˜ç³»ç»Ÿçš„å¯æ‰©å±•æ€§ã€‚
> 
> 
> 


ç»¼ä¸Šï¼Œçº¿ç¨‹æ± æ˜¯ä¸€ç§é‡è¦çš„å¤šçº¿ç¨‹ç¼–ç¨‹æŠ€æœ¯ï¼Œå®ƒèƒ½å¤Ÿæœ‰æ•ˆåœ°ç®¡ç†å’Œåˆ©ç”¨çº¿ç¨‹ï¼Œæé«˜ç¨‹åºçš„æ€§èƒ½å’Œèµ„æºåˆ©ç”¨ç‡ã€‚


### ğŸ˜Š2. çº¿ç¨‹æ± å®ç°1-å•å¤´æ–‡ä»¶


Githubé¡¹ç›®ï¼š`https://github.com/progschj/ThreadPool`


threadpoll.h



```
#ifndef THREAD\_POOL\_H
#define THREAD\_POOL\_H

#include <vector>
#include <queue>
#include <memory>
#include <thread>
#include <mutex>
#include <condition\_variable>
#include <future>
#include <functional>
#include <stdexcept>

class ThreadPool {
public:
    ThreadPool(size_t);
    // template enqueue: F & Args
    template<class F, class... Args>
    auto enqueue(F&& f, Args&&... args) // parameter list
        -> std::future<typename std::result_of<F(Args...)>::type>;  // return type
    ~ThreadPool();
private:
    // need to keep track of threads so we can join them
    std::vector< std::thread > workers;
    // the task queue
    std::queue< std::function<void()> > tasks;
    
    // synchronization: wait and wakeup
    std::mutex queue_mutex;
    std::condition_variable condition;
    bool stop;
};
 
// the constructor just launches some amount of workers
inline ThreadPool::ThreadPool(size_t threads)
    :   stop(false)
{
    for (size_t i = 0; i < threads; ++i)
        workers.emplace\_back(
            [this]
            {
                for(;;)
                {
                    // function template define
                    std::function<void()> task;
                    {
                        std::unique_lock<std::mutex> lock(this->queue_mutex);
                        // wait
                        this->condition.wait(lock,
                            [this]{ return this->stop || !this->tasks.empty(); });
                        if(this->stop && this->tasks.empty())
                            return;
                        // add and pop
                        task = std::move(this->tasks.front());
                        this->tasks.pop();
                    }

                    task();
                }
            }
    );
}

// add new work item to the pool
template<class F, class... Args>
auto ThreadPool::enqueue(F&& f, Args&&... args) 
    -> std::future<typename std::result_of<F(Args...)>::type>
{
    using return_type = typename std::result_of<F(Args...)>::type;

    auto task = std::make\_shared< std::packaged\_task<return\_type()> >(
            std::bind(std::forward<F>(f), std::forward<Args>(args)...)
        );
        
    std::future<return_type> res = task->get\_future();
    {
        std::unique_lock<std::mutex> lock(queue_mutex);

        // don't allow enqueueing after stopping the pool
        if(stop)
            throw std::runtime\_error("enqueue on stopped ThreadPool");

        tasks.emplace([task](){ (\*task)(); });
    }
    // wake up
    condition.notify\_one();
    return res;
}

// the destructor joins all threads
inline ThreadPool::~ThreadPool()
{
    {
        std::unique_lock<std::mutex> lock(queue_mutex);
        stop = true;
    }
    // wake up
    condition.notify\_all();
    for(std::thread &worker: workers)
        worker.join();
}

#endif

```

main.cpp



```
#include <iostream>
#include <vector>
#include <chrono>

#include "threadpoll.h"

int m\_sum(int x, int y) {
    return x + y;
}

int main()
{
    // åˆ›å»ºå®¹é‡ä¸º5çš„çº¿ç¨‹æ± 
    ThreadPool pool(5);

    // ç®€å•ä½¿ç”¨
    auto result_simple = pool.enqueue(m_sum, 3, 5);
    std::cout << "result\_simple: " << result_simple.get() << std::endl;

    // å¤æ‚ä½¿ç”¨
    std::vector< std::future<int> > results;

    for(int i = 0; i < 8; ++i) {
        results.emplace\_back(
            pool.enqueue([i] {
                std::cout << "hello " << i << std::endl;
                // std::this\_thread::sleep\_for(std::chrono::seconds(1));
                std::cout << "world " << i << std::endl;
                
                return i\*i;
            })
        );
    }

    std::this_thread::sleep\_for(std::chrono::seconds(2));
    std::cout << "result: ";
    for(auto && result: results)
        std::cout << result.get() << ' ';
    std::cout << std::endl;
    
    return 0;
}

```

ç¼–è¯‘è¿è¡Œï¼š



```
g++ -o main main.cpp -lpthread && ./main

```

**æ¨èä½¿ç”¨è¿™ä¸€ç§**ã€‚ä½¿ç”¨ä¸Šåœ¨åŸé¡¹ç›®åŸºç¡€ä¸Šè¿›è¡Œäº†æ‰©å……ï¼Œé€šè¿‡ä½¿ç”¨çº¿ç¨‹æ± ï¼Œå¯ä»¥å¾ˆæ–¹ä¾¿åœ°å¯¹çº¿ç¨‹è¿›è¡Œæ“ä½œï¼Œä¸”ä¸ç”¨è€ƒè™‘å¤šä»»åŠ¡çš„å†²çªç­‰ã€‚


### ğŸ˜†3. çº¿ç¨‹æ± å®ç°2-è¾ƒå¤æ‚


Githubé¡¹ç›®ï¼š`https://github.com/volute24/ThreadPoll`



```
// main.cpp
#include "threadpool.h"
#include <unistd.h>
#include <stdlib.h>
#include <stdio.h>

#define THREADPOOL\_MAX\_NUM 5

void\* mytask(void \*arg)
{
    printf("thread %d is working on task %d\n", (int)pthread\_self(), \*(int\*)arg);
    sleep(1);
    free(arg);
    return NULL;
}

int main(int argc, char\* argv[])
{
    threadpool_t pool;
    // åˆå§‹åŒ–çº¿ç¨‹æ± ï¼Œæœ€å¤š5ä¸ªçº¿ç¨‹
    threadpool\_init(&pool, THREADPOOL_MAX_NUM);
	// åˆ›å»º10ä¸ªä»»åŠ¡
    for(int i=0; i < 10; i++)
    {
        int \*arg =(int \*)malloc(sizeof(int));
        \*arg = i;
        threadpool\_add\_task(&pool, mytask, arg);
        //printf("arg address:%p,arg:[%d],i:[%d]\n",arg,\*arg,i);
    }
    threadpool\_destroy(&pool);
    return 0;
}

```


```
// threadpool.h
#ifndef \_THREAD\_POLL\_H\_
#define \_THREAD\_POLL\_H\_

#include "condition.h"

// å°è£…çº¿ç¨‹æ± ä¸­çš„å¯¹è±¡éœ€è¦æ‰§è¡Œçš„ä»»åŠ¡å¯¹è±¡
typedef struct task
{
	void \*(\*run)(void \*args);//å‡½æ•°æŒ‡é’ˆï¼Œéœ€è¦æ‰§è¡Œçš„ä»»åŠ¡
	void \*arg;			//å‚æ•°
	struct task \*next;	//ä»»åŠ¡é˜Ÿåˆ—ä¸­ä¸‹ä¸€ä¸ªä»»åŠ¡
}task_t;

//å®šä¹‰çº¿ç¨‹æ± ç»“æ„ä½“
typedef struct threadpool
{
	condition_t ready;   //çŠ¶æ€é‡
	task_t \*first;	     //ä»»åŠ¡é˜Ÿåˆ—ä¸­ç¬¬ä¸€ä¸ªä»»åŠ¡
	task_t \*last;		//ä»»åŠ¡é˜Ÿåˆ—ä¸­æœ€åä¸€ä¸ªä»»åŠ¡
	int counter;		//çº¿ç¨‹æ± ä¸­å·²æœ‰çº¿ç¨‹æ•°
	int idle;			//çº¿ç¨‹æ± ä¸­ç©ºé—²çº¿ç¨‹æ•°
	int max_threads;	//çº¿ç¨‹æ± æœ€å¤§çº¿ç¨‹æ•°
	int quit;			//æ˜¯å¦é€€å‡ºæ ‡å¿—
}threadpool_t;

//çº¿ç¨‹æ± åˆå§‹åŒ–
void threadpool\_init(threadpool_t \*pool,int threads);
//çº¿ç¨‹æ± ä¸­åŠ å…¥ä»»åŠ¡
void threadpool\_add\_task(threadpool_t \*pool,void \*(\*run)(void \*args),void \*arg);
//é”€æ¯çº¿ç¨‹æ± 
void threadpool\_destroy(threadpool_t \*pool);

#endif

```


```
// threadpoll.cpp
#include "threadpool.h"
#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <errno.h>
#include <time.h>
#include <pthread.h>

using namespace std;

//çº¿ç¨‹æ‰§è¡Œ
void \*thread\_routine(void \*arg)
{
	struct timespec abstime;
	int timeout;
	printf("thread %d is starting\n",(int)pthread\_self());
	threadpool_t \*pool = (threadpool_t \*)arg;

	while(1)
	{
		timeout = 0;
		//è®¿é—®æ± å‰åŠ é”
		condition\_lock(&pool->ready);
		//ç©ºé—²
		pool->idle++;
		//ç­‰å¾…é˜Ÿåˆ—ä»»åŠ¡|| æ”¶åˆ°çº¿ç¨‹æ± é”€æ¯é€šçŸ¥
		while(pool->first == NULL && !pool->quit)
		{
			//å¦åˆ™çº¿ç¨‹é˜»å¡ç­‰å¾…
			printf("thread %d is waiting\n",(int)pthread\_self());
			//è·å–ä»å½“å‰æ—¶é—´åŠ ä¸Šç­‰å¾…æ—¶é—´ï¼Œè®¾ç½®è¶…æ—¶ç¡çœ æ—¶é—´
			//clock\_gettime åœ¨ç¼–è¯‘é“¾æ¥æ—¶éœ€åŠ ä¸Š -lrt ,librtä¸­å®ç°äº†clock\_gettimeå‡½æ•°
			clock\_gettime(CLOCK_REALTIME,&abstime);  //CLOCK\_REALTIME ç³»ç»Ÿå®æ—¶æ—¶é—´
			abstime.tv_sec += 2;
			int status;
			status = condition\_timedwait(&pool->ready,&abstime);
			if(status == ETIMEDOUT)
			{
				printf("thread %d wait timed out\n",(int)pthread\_self());
				timeout = -1;
				break;
			}
		}

		pool->idle--;
		
		if(pool->first != NULL)
		{
		 	//å–å‡ºç­‰å¾…é˜Ÿåˆ—æœ€å‰ä»»åŠ¡ï¼Œç§»é™¤ä»»åŠ¡ï¼Œå¹¶æ‰§è¡Œä»»åŠ¡
		 	task_t \*t = pool->first;
			pool->first = t->next;
			//ç”±äºä»»åŠ¡æ‰§è¡Œéœ€è¦æ¶ˆè€—æ—¶é—´ï¼Œå…ˆè§£é”è®©å…¶ä»–çº¿ç¨‹è®¿é—®çº¿ç¨‹æ± 
			condition\_unlock(&pool->ready);
			//æ‰§è¡Œä»»åŠ¡
			t->run(t->arg);
			//æ‰§è¡Œå®Œä»»åŠ¡é‡Šæ”¾å†…å­˜
            free(t);
           	//é‡æ–°åŠ é”
            condition\_lock(&pool->ready);	
		}
		//é€€å‡ºçº¿ç¨‹æ± 
	        if(pool->quit && pool->first == NULL)
	        {
	            pool->counter--;
	            //è‹¥çº¿ç¨‹æ± ä¸­æ²¡æœ‰çº¿ç¨‹ï¼Œé€šçŸ¥ç­‰å¾…çº¿ç¨‹ï¼ˆä¸»çº¿ç¨‹ï¼‰å…¨éƒ¨ä»»åŠ¡å·²ç»å®Œæˆ
	            if(pool->counter == 0)
	            {
	                condition\_signal(&pool->ready);
	            }
	            condition\_unlock(&pool->ready);
	            break;
	        }
		 	//è¶…æ—¶ï¼Œè·³å‡ºé”€æ¯çº¿ç¨‹
	        if(timeout == 1)
	        {
	            pool->counter--;
	            condition\_unlock(&pool->ready);
	            break;
	        }
			condition\_unlock(&pool->ready);
	}
    printf("thread %d is exiting\n", (int)pthread\_self());
    return NULL;
}

//çº¿ç¨‹æ± åˆå§‹åŒ–
void threadpool\_init(threadpool_t \*pool, int threads)
{
    
    int nstatu = condition\_init(&pool-ready>);
    printf("Init return values:%d\n",nstatu);
    pool->first = NULL;
    pool->last =NULL;
    pool->counter =0;
    pool->idle =0;
    pool->max_threads = threads;
    pool->quit =0;
    
}

//å¢åŠ ä¸€ä¸ªä»»åŠ¡åˆ°çº¿ç¨‹æ± 
void threadpool\_add\_task(threadpool_t \*pool, void \*(\*run)(void \*arg), void \*arg)
{
    //äº§ç”Ÿä¸€ä¸ªæ–°çš„ä»»åŠ¡
    task_t \*newtask = (task_t \*)malloc(sizeof(task_t));
    newtask->run = run;
    newtask->arg = arg;
    newtask->next=NULL;//æ–°åŠ çš„ä»»åŠ¡æ”¾åœ¨é˜Ÿåˆ—å°¾ç«¯
    
    //çº¿ç¨‹æ± çš„çŠ¶æ€è¢«å¤šä¸ªçº¿ç¨‹å…±äº«ï¼Œæ“ä½œå‰éœ€è¦åŠ é”
    condition\_lock(&pool->ready);
    
    if(pool->first == NULL)
    {
        pool->first = newtask;
    }        
    else    
    {
        pool->last->next = newtask;
    }
    pool->last = newtask;  //é˜Ÿåˆ—å°¾æŒ‡å‘æ–°åŠ å…¥çš„çº¿ç¨‹
    
    //çº¿ç¨‹æ± ä¸­æœ‰çº¿ç¨‹ç©ºé—²ï¼Œå”¤é†’
    if(pool->idle > 0)
    {
        condition\_signal(&pool->ready);
    }
    //å½“å‰çº¿ç¨‹æ± ä¸­çº¿ç¨‹ä¸ªæ•°æ²¡æœ‰è¾¾åˆ°è®¾å®šçš„æœ€å¤§å€¼ï¼Œåˆ›å»ºä¸€ä¸ªæ–°çš„çº¿ç¨‹
    else if(pool->counter < pool->max_threads)
    {
        pthread_t tid;
        pthread\_create(&tid, NULL, thread_routine,pool);
        pool->counter++;
    }
    //ç»“æŸï¼Œè®¿é—®è§£é”
    condition\_unlock(&pool->ready);
}

//çº¿ç¨‹æ± é”€æ¯
void threadpool\_destroy(threadpool_t \*pool)
{
    if(pool->quit)
    {
    return;
    }
    condition\_lock(&pool->ready);
    pool->quit = 1;
    //çº¿ç¨‹æ± ä¸­çº¿ç¨‹ä¸ªæ•°å¤§äº0
    if(pool->counter > 0)
    {
        //å¯¹äºç­‰å¾…çš„çº¿ç¨‹ï¼Œå‘é€ä¿¡å·å”¤é†’
        if(pool->idle > 0)
        {
            condition\_broadcast(&pool->ready);
        }
        //æ­£åœ¨æ‰§è¡Œä»»åŠ¡çš„çº¿ç¨‹ï¼Œç­‰å¾…ä»–ä»¬ç»“æŸä»»åŠ¡
        while(pool->counter)
        {
            condition\_wait(&pool->ready);
        }
    }
    condition\_unlock(&pool->ready);
    condition\_destroy(&pool->ready);
}

```

ã€‚ã€‚ã€‚


ç¼–è¯‘ï¼š`g++ main.cpp condition.cpp threadpool.cpp -lpthread`


è¿è¡Œå¦‚ä¸‹ï¼š



```
Init return values:0
thread 1696954112 is starting
thread 1705346816 is starting
thread 1688561408 is starting
thread 1688561408 is working on task 0
thread 1671776000 is starting
thread 1671776000 is working on task 2
thread 1705346816 is working on task 1
thread 1696954112 is working on task 3
thread 1680168704 is starting
thread 1680168704 is working on task 4
thread 1688561408 is working on task 5
thread 1671776000 is working on task 6
thread 1705346816 is working on task 7
thread 1680168704 is working on task 8
thread 1696954112 is working on task 9
thread 1680168704 is exiting
thread 1705346816 is exiting
thread 1696954112 is exiting

```

![åœ¨è¿™é‡Œæ’å…¥å›¾ç‰‡æè¿°](https://img-blog.csdnimg.cn/6567c240f1b5443ab60e194d3ffe3803.png)


ä»¥ä¸Šã€‚





